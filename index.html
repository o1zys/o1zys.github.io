<!doctype html>



  


<html class="theme-next pisces use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="Programmer">
<meta property="og:type" content="website">
<meta property="og:title" content="Oizys&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Oizys&#39;s Blog">
<meta property="og:description" content="Programmer">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Oizys&#39;s Blog">
<meta name="twitter:description" content="Programmer">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Oizys's Blog</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Oizys's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/26/Sort/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Oizys">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/o1zys">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Oizys's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/26/Sort/" itemprop="url">排序算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-26T17:42:56+08:00">
                2017-12-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/12/26/Sort/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/12/26/Sort/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bubble_sort</span> <span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</div><div class="line">			<span class="keyword">if</span> (a[i] &gt; a[j]) &#123;</div><div class="line">				Swap(a[i], a[j]);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Swap 函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span>  &amp;a, <span class="keyword">int</span> &amp; b)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> tmp = <span class="number">0</span>;</div><div class="line">	tmp = a;</div><div class="line">	a = b;</div><div class="line">	b = tmp;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//  or:</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span>  &amp;a, <span class="keyword">int</span> &amp; b)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (a != b) &#123;</div><div class="line">		a ^= b;</div><div class="line">		b ^= a;</div><div class="line">		a ^= b;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Select_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++) &#123;</div><div class="line">		min_index = i;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</div><div class="line">			<span class="keyword">if</span> (a[j] &gt; a[min_index]) </div><div class="line">				min_index = j;</div><div class="line">		&#125;</div><div class="line">		Swap (a[i], a[min_index]);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p>插入排序的思想有点像打扑克抓牌的时候，我们插入扑克牌的做法。想象一下，抓牌时，我们都是把抓到的牌按顺序放在手中。因此每抓一张新牌，我们都将其插入到已有的排好序的手牌当中，</p>
<p>当前抓到第<code>i</code>张牌<code>key = a[i]</code>，让其与排好顺序的<code>i-1</code>张牌，从后往前比较，大于<code>key</code>的话就往后移，直到遇到一个不大于<code>key</code>的牌，将<code>key</code>插入到这个位置后面。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++) &#123;</div><div class="line">		<span class="keyword">int</span> key = a[i];</div><div class="line">		<span class="keyword">int</span> j = i <span class="number">-1</span>;</div><div class="line">		<span class="keyword">while</span> (j &gt;=<span class="number">0</span> &amp;&amp; a[j]&gt; key ) &#123;</div><div class="line">			a[j+<span class="number">1</span>] = a[j];</div><div class="line">			j--;</div><div class="line">		&#125;</div><div class="line">		a[j+<span class="number">1</span>] = key;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。</p>
<p>其实希尔排序就是对相隔若干距离的数据进行直接插入排序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Shell_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n, <span class="keyword">int</span> step)</span> </span>&#123;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> gap = n/step;  gap &gt; <span class="number">0</span>; gap /= step )</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; gap; k++) &#123;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; n; i += gap) &#123;</div><div class="line">				<span class="keyword">int</span> key = a[i];</div><div class="line">				<span class="keyword">int</span> j = i - gap;</div><div class="line">				While (j &gt;= <span class="number">0</span> &amp;&amp; a[j]&gt; key ) &#123;</div><div class="line">					a[j+gap] = a[j];</div><div class="line">					j -= gap;</div><div class="line">				&#125;</div><div class="line">				a[j+gap] = key;</div><div class="line">			&#125;		</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序的主要思想是分治法（Divide and Conquer）。</p>
<p>首先考虑下如何将将二个有序数列合并。这个非常简单，只要从比较二个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可。</p>
<p>然后分治递归实现合并排序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergearray</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> first, <span class="keyword">int</span> mid, <span class="keyword">int</span> last , <span class="keyword">int</span> temp)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> i = first, j = mid +<span class="number">1</span>;</div><div class="line">	<span class="keyword">int</span> m = mid, n = last;</div><div class="line">	<span class="keyword">int</span> k = <span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span> (i &lt;= m &amp;&amp; j &lt;= n) &#123;</div><div class="line">		If (a[i] &lt; a[j]) &#123;</div><div class="line">			temp[k++] = a[i++];</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			temp[k++] = a[j++];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">while</span> (j &lt;= n) </div><div class="line">		temp[k++] = a[j++];</div><div class="line">	<span class="keyword">while</span> (i &lt;= m) </div><div class="line">		temp[k++] = a[i++];</div><div class="line">		</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;k; i++) &#123;</div><div class="line">		a[first+i] = temp[i];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> first,  <span class="keyword">int</span> last, <span class="keyword">int</span> temp[])</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (first &lt; last) &#123;</div><div class="line">		<span class="keyword">int</span> mid = (first + last) / <span class="number">2</span>;</div><div class="line">		Merge_sort(a, first, mid, temp );</div><div class="line">		Merge_sort(a, mid+<span class="number">1</span>, last, temp );</div><div class="line">		mergearray(a, first, mid, last, temp);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>即挖坑填数+分治。</p>
<p>挖坑填数:</p>
<ol>
<li><code>i = l</code>; <code>j = r</code>; 将基准数<code>key</code>挖出形成第一个坑 <code>a[i]</code>。</li>
<li><code>j--</code>由后向前找比它小的数，找到后挖出此数填前一个坑 <code>a[i]</code>中。</li>
<li><code>i++</code>由前向后找比它大的数，找到后也挖出此数填到前一个坑 <code>a[j]</code>中。</li>
<li>再重复执行2，3二步，直到<code>i == j</code>，将基准数<code>key</code>填入<code>a[i]</code>中。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Quick_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (l &lt; r) &#123;</div><div class="line">		<span class="keyword">int</span> i = l, j = r, key = a[l];</div><div class="line">		<span class="keyword">while</span> (i &lt; j) &#123;</div><div class="line">			<span class="keyword">while</span>(i &lt; j &amp;&amp; a[j] &gt;= key) <span class="comment">// 从右向左找第一个小于key的数</span></div><div class="line">				j--;</div><div class="line">          <span class="keyword">if</span>(i &lt; j)   </div><div class="line">          	a[i++] = a[j];</div><div class="line">          	</div><div class="line">          <span class="keyword">while</span>(i &lt; j &amp;&amp; a[i] &lt; key) <span class="comment">// 从左向右找第一个大于等于key的数  </span></div><div class="line">          	i++;</div><div class="line">          <span class="keyword">if</span>(i &lt; j)</div><div class="line">          	a[j--] = a[i];</div><div class="line">		&#125;</div><div class="line">		a[i] = key;</div><div class="line">		Quick_sort(a, l, i - <span class="number">1</span>); <span class="comment">// 递归调用</span></div><div class="line">		Quick_sort(a, i + <span class="number">1</span>, r);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h3><p>二叉堆是完全二叉树或者是近似完全二叉树。</p>
<p>二叉堆满足两个特性：</p>
<ol>
<li>父结点的键值总是大于或等于（小于或等于）任何一个子节点的键值。</li>
<li>每个结点的左子树和右子树都是一个二叉堆（都是最大堆或最小堆）。</li>
</ol>
<p>当父结点的键值总是大于或等于任何一个子节点的键值时为<strong>最大堆</strong>。当父结点的键值总是小于或等于任何一个子节点的键值时为<strong>最小堆</strong>。下图展示一个最小堆：</p>
<p><img src="https://raw.githubusercontent.com/o1zys/MarkdownImage/master/heap0.png" alt=""></p>
<h3 id="堆的储存"><a href="#堆的储存" class="headerlink" title="堆的储存"></a>堆的储存</h3><p>一般都用数组来表示堆，i结点的父结点下标就为<code>(i–1)/2</code>。它的左右子结点下标分别为<code>2*i+1</code>和<code>2*i+2</code>。如第<code>0</code>个结点左右子结点下标分别为<code>1</code>和<code>2</code>。上图堆的储存结构为：</p>
<table>
<thead>
<tr>
<th>10</th>
<th>15</th>
<th>30</th>
<th>40</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<h3 id="堆的操作"><a href="#堆的操作" class="headerlink" title="堆的操作"></a>堆的操作</h3><ol>
<li><p>建立堆：数组具有对应的树的表示形式。一般情况下，树并不能满足堆的条件，通过重新排列元素，可以建立堆化树。</p>
<p> 初始表： 40 10 30， 堆化树：10 40 30</p>
<p> <img src="https://raw.githubusercontent.com/o1zys/MarkdownImage/master/heap1.png" alt=""></p>
</li>
<li><p>插入一个元素：新元素被加入到最底层，随后树被更新恢复堆，如下面将15加入表中。</p>
<p> <img src="https://raw.githubusercontent.com/o1zys/MarkdownImage/master/heap2.png" alt=""></p>
</li>
<li><p>删除一个元素：删除总发生在根节点，最后一个元素用来填补空缺位置，结果树更新恢复堆。</p>
<p> <img src="https://raw.githubusercontent.com/o1zys/MarkdownImage/master/heap3.png" alt=""></p>
</li>
</ol>
<p>由以上分析我们可以得知，插入操作其实就是一个从下往上调整的过程：<br>将元素插入到最后，从下往上与其父节点比较，小于父节点则交换，重复这个过程直到根节点。这是一个“上浮”的过程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n, <span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">	a[n] = num;</div><div class="line">	FixUp(a, n);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">FixUp</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">	<span class="keyword">while</span> (<span class="keyword">int</span> j = (i<span class="number">-1</span>)/<span class="number">2</span>; j&gt;=<span class="number">0</span> &amp;&amp; a[j] &gt; a[i]; i = j, j = (i<span class="number">-1</span>)/<span class="number">2</span>) &#123;</div><div class="line">			Swap(a[i], a[j]);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而删除操作则是一个从上往下调整的过程：<br>先删除根节点，将最后一个元素插入到根节点，从上往下与其左右节点比较，大于左右节点中最小的一个则交换，重复这个过程直到比左右节点都小，这时就不用调整了。这是一个“下沉”的过程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">	Swap(a[<span class="number">0</span>], a[n<span class="number">-1</span>]);</div><div class="line">	FixDown(a, <span class="number">0</span>, n<span class="number">-1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">FixDown</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> j = <span class="number">2</span>*i+<span class="number">1</span>;</div><div class="line">	<span class="keyword">while</span>(j &lt; n) &#123;</div><div class="line">		<span class="keyword">if</span> (j+<span class="number">1</span> &lt; n &amp;&amp; a[j+<span class="number">1</span>] &lt; a[j]) j++;</div><div class="line">		<span class="keyword">if</span> (a[j] &lt; a[i]) Swap(a[i], a[j]);</div><div class="line">		<span class="keyword">else</span> <span class="keyword">break</span>;</div><div class="line">		i = j;</div><div class="line">		j = <span class="number">2</span>*i+<span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>讲完<code>FixUp</code>和<code>FixDown</code>操作之后，给定一个无序数组，我们可以很方便的建立起一个堆。</p>
<p>从最后一个元素(n-1)的父节点开始，到根节点进行<code>FixDown</code>操作，就能建立起一个最小堆了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">MakeMinHeap</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n/<span class="number">2</span><span class="number">-1</span>; i &gt;=<span class="number">0</span> ; i--) &#123; 	<span class="comment">//最后一个元素的父节点为((n-1)-1)/2, 即n/2-1</span></div><div class="line">		FixDown(a, i, n);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h3><p>首先可以看到堆建好之后堆中第0个数据是堆中最小的数据。取出这个数据再执行下堆的删除操作。这样堆中第0个数据又是堆中最小的数据，重复上述步骤直至堆中只有一个数据时就直接取出这个数据。</p>
<p>由于堆也是用数组模拟的，故堆化数组后，第一次将<code>a[0]</code>与<code>a[n-1]</code>交换，再对<code>a[0...n-2]</code>重新恢复堆。第二次将<code>a[0]</code>与<code>a[n–2]</code>交换，再对<code>a[0...n-3]</code>重新恢复堆，重复这样的操作直到<code>a[0]</code>与<code>a[1]</code>交换。由于每次都是将最小的数据并入到后面的有序区间，故操作完成后整个数组就有序了。有点类似于直接选择排序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">	MakeMinHeap(a, n);</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;  </div><div class="line">        Swap(a[i], a[<span class="number">0</span>]);  </div><div class="line">        FixDown(a, <span class="number">0</span>, i);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意使用最小堆排序后是递减数组，要得到递增数组，可以使用最大堆。</p>
<p>由于每次重新恢复堆的时间复杂度为<code>O(logN)</code>，共<code>N-1</code>次重新恢复堆操作，再加上前面建立堆时<code>N/2</code>次向下调整，每次调整时间复杂度也为<code>O(logN)</code>。二次操作时间相加还是<code>O(N*logN)</code>。故堆排序的时间复杂度为<code>O(N*logN)</code>。</p>
<h2 id="排序总结"><a href="#排序总结" class="headerlink" title="排序总结"></a>排序总结</h2><p><img src="https://raw.githubusercontent.com/o1zys/MarkdownImage/master/sort_complexity.png" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/25/CppS4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Oizys">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/o1zys">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Oizys's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/25/CppS4/" itemprop="url">C++ Section4 内存管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-25T19:07:45+08:00">
                2017-12-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/" itemprop="url" rel="index">
                    <span itemprop="name">cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/12/25/CppS4/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/12/25/CppS4/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="new与malloc的区别，delet和free的区别及其内部实现"><a href="#new与malloc的区别，delet和free的区别及其内部实现" class="headerlink" title="new与malloc的区别，delet和free的区别及其内部实现"></a>new与malloc的区别，delet和free的区别及其内部实现</h2><h3 id="new-与-malloc的区别："><a href="#new-与-malloc的区别：" class="headerlink" title="new 与 malloc的区别："></a>new 与 malloc的区别：</h3><ol>
<li>new 是运算符，malloc是库函数</li>
<li>new会调用构造函数，malloc只申请内存</li>
<li>new返回指定类型的指针，malloc返回void指针</li>
<li>new自动计算所需的内存大小，malloc需要手动设置空间</li>
<li>new可以被重载</li>
</ol>
<p>内部实现：<br><img src="https://raw.githubusercontent.com/o1zys/MarkdownImage/master/cpp_s4_1.png" alt=""></p>
<h3 id="delete-和-free-的区别："><a href="#delete-和-free-的区别：" class="headerlink" title="delete 和 free 的区别："></a>delete 和 free 的区别：</h3><ol>
<li>delete 是运算符，free是库函数</li>
<li>delete会调用析构函数，free是会释放内存</li>
<li>使用free之前要检查指针是否为空指针，delete不需要，对空指针delete没有问题</li>
<li>free 和 delete 不能混用，也就是说new 分配的内存空间最好不要使用使用free 来释放，malloc 分配的空间也不要使用 delete来释放</li>
</ol>
<p>内部实现：<br><img src="https://raw.githubusercontent.com/o1zys/MarkdownImage/master/cpp_s4_2.png" alt=""></p>
<h2 id="malloc-calloc-realloc-和-alloca-申请内存的区别"><a href="#malloc-calloc-realloc-和-alloca-申请内存的区别" class="headerlink" title="malloc, calloc, realloc, 和 alloca 申请内存的区别"></a>malloc, calloc, realloc, 和 alloca 申请内存的区别</h2><ol>
<li>calloc 是申请N个大小为S的空间，且会初始化空间值为0；malloc不会初始化，是随机的垃圾数据（在VS Debug模式下，会是0xcccccc这种特殊值，为了调试方便）</li>
<li>malloc 是在堆上申请大小为S的一个空间，但不会初始化</li>
<li>realloc 是将原本分配的内存扩充到新的大小，要求新的大小必须大于原大小</li>
<li>alloca 是在栈上申请空间，不需要（不能）使用free，运行到作用域以外的时候释放申请的空间</li>
</ol>
<h2 id="C-内存模型（堆、栈、静态区）"><a href="#C-内存模型（堆、栈、静态区）" class="headerlink" title="C++内存模型（堆、栈、静态区）"></a>C++内存模型（堆、栈、静态区）</h2><p>堆 heap ：<br>由new分配的内存块，其释放编译器不去管，由我们程序自己控制（一个new对应一个delete）。如果程序员没有释放掉，在程序结束时OS会自动回收。涉及的问题：“缓冲区溢出”、“内存泄露”</p>
<p>栈 stack ：<br>是那些编译器在需要时分配，在不需要时自动清除的存储区。存放局部变量、函数参数。存放在栈中的数据只在当前函数及下一层函数中有效，一旦函数返回了，这些数据也就自动释放了。函数栈内的变量地址总是连续的，从高地址向低地址生长。</p>
<p>全局/静态存储区 （.bss段和.data段） ：<br>全局和静态变量被分配到同一块内存中。在C语言中，未初始化的静态变量放在.bss段中，初始化的放在.data段中；在C++里则不区分了。</p>
<p>常量存储区 （.rodata段） ：<br>存放常量，不允许修改（通过非正当手段也可以修改）</p>
<p>代码区 （.text段） ：<br>存放代码（如函数），不允许修改（类似常量存储区），但可以执行（不同于常量存储区）<br>根据c/c++对象生命周期不同，c/c++的内存模型有三种不同的内存区域，即</p>
<p>自由存储区（栈区）：局部非静态变量的存储区域，即平常所说的栈<br>动态存储区（堆区）： 用operator new ，malloc分配的内存，即平常所说的堆<br>静态存储区：全局变量 静态变量 字符串常量存在位置</p>
<p>注意：<br>栈区变量要注意析构函数的调用次序，由于是先进后出，则先创建的对象，最后被析构。</p>
<h2 id="堆与栈的区别"><a href="#堆与栈的区别" class="headerlink" title="堆与栈的区别"></a>堆与栈的区别</h2><ol>
<li>堆是先进先出，栈是先进后出。</li>
<li>栈的大小固定，受限于系统中有效的虚拟内存，可能会发生栈溢出；堆可以动态生长</li>
<li>栈的空间有系统释放，堆内存由程序员释放</li>
<li>堆容易产生碎片</li>
<li>申请方式上，栈是系统自动分配，堆是由程序员申请</li>
</ol>
<h2 id="如何实现只能动态分配类对象，不能定义类对象"><a href="#如何实现只能动态分配类对象，不能定义类对象" class="headerlink" title="如何实现只能动态分配类对象，不能定义类对象"></a>如何实现只能动态分配类对象，不能定义类对象</h2><p>即只能将对象创建于堆上，不能创建于栈上。需要把构造函数和析构函数设为protected，派生类可以访问，外部无法访问。同时创建create和destroy函数,在内部调用构造和析构，用于创建和删除对象。其中create设为static，使用类名访问。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></div><div class="line"><span class="keyword">protected</span>:</div><div class="line"> 	A()&#123;&#125;;</div><div class="line"> 	~A()&#123;&#125;;</div><div class="line"><span class="keyword">public</span>:</div><div class="line"> 	<span class="function"><span class="keyword">static</span> A* <span class="title">creat</span><span class="params">()</span></span>&#123;</div><div class="line"> 		<span class="keyword">return</span> <span class="keyword">new</span> A();</div><div class="line"> 	&#125;</div><div class="line"> 	<span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123;</div><div class="line"> 		<span class="keyword">delete</span> <span class="keyword">this</span>;</div><div class="line"> 	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line"> 	A* a = A::creat();</div><div class="line">	a-&gt;destroy();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="如何实现只能在栈上创建对象-不能在堆上创建对像"><a href="#如何实现只能在栈上创建对象-不能在堆上创建对像" class="headerlink" title="如何实现只能在栈上创建对象, 不能在堆上创建对像"></a>如何实现只能在栈上创建对象, 不能在堆上创建对像</h2><p>在堆上创建对象的唯一方法是使用new关键字，所以，只需要禁用new关键字就可以了。将operator new 设为私有的, 外部不可访问。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">	<span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> t)</span></span>&#123;&#125;     <span class="comment">// 注意函数的第一个参数和返回值都是固定的</span></div><div class="line"> 	<span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr)</span></span>&#123;&#125; <span class="comment">// 重载了new就需要重载delete</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line"> 	A()&#123;&#125;</div><div class="line"> 	~A()&#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="析构函数什么时候声明为私有？什么时候不能声明为私有？"><a href="#析构函数什么时候声明为私有？什么时候不能声明为私有？" class="headerlink" title="析构函数什么时候声明为私有？什么时候不能声明为私有？"></a>析构函数什么时候声明为私有？什么时候不能声明为私有？</h2><p>私有析构函数可以使得对象只在堆上构造。在栈上创建的对象要求构造函数和析构函数必须都是公有的，否则编译器报错“析构函数不可访问”；而堆对象由程序员创建和删除，可以把析构函数声明为私有的。由于delete会调用析构函数，而私有的析构无法被访问，编译器报错，此时通过增加一个destroy()方法，在方法内调用析构函数来释放对象:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">delete</span> <span class="keyword">this</span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>析构函数不能声明为私有的情况：基类的析构函数不能声明为私有，因为要在派生类的析构函数中被隐式调用。</p>
<h2 id="构造函数什么时候声明为私有？什么时候不能声明为私有？"><a href="#构造函数什么时候声明为私有？什么时候不能声明为私有？" class="headerlink" title="构造函数什么时候声明为私有？什么时候不能声明为私有？"></a>构造函数什么时候声明为私有？什么时候不能声明为私有？</h2><p>单例模式时构造函数声明为私有。</p>
<p>基类的构造函数不能声明为私有，因为要在派生类的构造函数中被隐式调用。如果在派生类的构造函数中没有显式调用基类的构造，则会调用基类的默认构造函数。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/25/CppS3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Oizys">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/o1zys">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Oizys's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/25/CppS3/" itemprop="url">C++ Section3 泛型编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-25T19:07:33+08:00">
                2017-12-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/" itemprop="url" rel="index">
                    <span itemprop="name">cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/12/25/CppS3/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/12/25/CppS3/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="模板通式"><a href="#模板通式" class="headerlink" title="模板通式"></a>模板通式</h2><h3 id="函数模板通式"><a href="#函数模板通式" class="headerlink" title="函数模板通式"></a>函数模板通式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> 形参名，<span class="title">class</span> 形参名，...&gt; </span></div><div class="line">返回类型 函数名(参数列表) &#123;</div><div class="line">	函数体</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="类模板通式"><a href="#类模板通式" class="headerlink" title="类模板通式"></a>类模板通式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> 形参名，<span class="title">class</span> 形参名, ...&gt;   </span></div><div class="line"><span class="title">class</span> 类名</div><div class="line">&#123; ... &#125;;</div></pre></td></tr></table></figure>
<h2 id="模板的非类型形参"><a href="#模板的非类型形参" class="headerlink" title="模板的非类型形参"></a>模板的非类型形参</h2><ol>
<li><p>非类型模板形参：模板的非类型形参也就是内置类型形参，如template<class t,="" int="" a=""> class B{};其中int a就是非类型的模板形参。</class></p>
</li>
<li><p>非类型形参在模板定义的内部是常量值，也就是说非类型形参在模板的内部是常量。</p>
</li>
<li><p>非类型模板的形参只能是<strong>整型</strong>，<strong>指针</strong>和<strong>引用</strong>，像double，String, String **这样的类型是不允许的。但是double &amp;，double *，对象的引用或指针是正确的。</p>
</li>
<li><p>调用非类型模板形参的实参必须是一个常量表达式，即他必须能在编译时计算出结果。</p>
</li>
<li><p>注意：任何局部对象，局部变量，局部对象的地址，局部变量的地址都不是一个常量表达式，都不能用作非类型模板形参的实参。全局指针类型，全局变量，全局对象也不是一个常量表达式，不能用作非类型模板形参的实参。</p>
</li>
<li><p>全局变量的地址或引用，全局对象的地址或引用const类型变量是常量表达式，可以用作非类型模板形参的实参。</p>
</li>
<li><p>sizeof表达式的结果是一个常量表达式，也能用作非类型模板形参的实参。</p>
</li>
<li><p>当模板的形参是整型时调用该模板时的实参必须是整型的，且在编译期间是常量，比如template <class t,="" int="" a=""> class A{};如果有int b，这时A<int, b=""> m;将出错，因为b不是常量，如果const int b，这时A<int, b=""> m;就是正确的，因为这时b是常量。</int,></int,></class></p>
</li>
<li><p>非类型形参一般不应用于函数模板中，比如有函数模板template<class t,="" int="" a=""> void h(T b){}，若使用h(2)调用会出现无法为非类型形参a推演出参数的错误，对这种模板函数可以用显示模板实参来解决，如用h<int, 3="">(2)这样就把非类型形参a设置为整数3。显示模板实参在后面介绍。</int,></class></p>
</li>
<li><p>非类型模板形参的形参和实参间所允许的转换</p>
<ul>
<li>允许从数组到指针，从函数到指针的转换。如：template <int \*a=""> class A{}; int b[1]; A\<b\> m;即数组到指针的转换</b\></int></li>
<li>const修饰符的转换。如：template<const int="" \*a=""> class A{}; int b; A\&lt;&amp;b> m;   即从int *到const int *的转换。</const></li>
<li>提升转换。如：template<int a=""> class A{}; const short b=2; A\<b\> m; 即从short到int的提升转换</b\></int></li>
<li>整值转换。如：template<unsigned int="" a=""> class A{};   A<3> m; 即从int 到unsigned int的转换。</3></unsigned></li>
<li>常规转换。</li>
</ul>
</li>
</ol>
<h3 id="非类型模板的应用：Stack类"><a href="#非类型模板的应用：Stack类" class="headerlink" title="非类型模板的应用：Stack类"></a>非类型模板的应用：Stack类</h3><p>stack.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STACK_H</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_H</span></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">int</span> <span class="title">MAXSIZE</span>&gt; </span></div><div class="line"><span class="title">class</span> <span class="title">Stack</span> &#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">	T 		elems[MAXSIZE];</div><div class="line">	<span class="keyword">int</span> 	numElems;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	Stack();</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span>&amp;)</span></span>;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;</div><div class="line">	<span class="function">T <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> numElems == <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> numElems == MAXSIZE;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">int</span> <span class="title">MAXSIZE</span>&gt; </span></div><div class="line"><span class="title">Stack</span>&lt;T,MAXSIZE&gt;::Stack():numElems(<span class="number">0</span>)&#123;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">int</span> <span class="title">MAXSIZE</span>&gt;</span></div><div class="line"><span class="title">void</span> <span class="title">Stack</span>&lt;T, MAXSIZE&gt;::push(T <span class="keyword">const</span>&amp; elem)&#123;</div><div class="line">	<span class="keyword">if</span>(numElems == MAXSIZE)&#123;</div><div class="line">		<span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(<span class="string">"Stack&lt;&gt;::push(): stack is full"</span>);</div><div class="line">	&#125;</div><div class="line">	elems[numElems] = elem;	</div><div class="line">	++numElems;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">int</span> <span class="title">MAXSIZE</span>&gt;</span></div><div class="line"><span class="title">void</span> <span class="title">Stack</span>&lt;T,MAXSIZE&gt;::pop()&#123;</div><div class="line">	<span class="keyword">if</span> (numElems &lt;= <span class="number">0</span>) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(<span class="string">"Stack&lt;&gt;::pop(): empty stack"</span>);</div><div class="line">	&#125;</div><div class="line">    --numElems;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">int</span> <span class="title">MAXSIZE</span>&gt;</span></div><div class="line"><span class="title">T</span> <span class="title">Stack</span>&lt;T,MAXSIZE&gt;::top() <span class="keyword">const</span>&#123;</div><div class="line">    <span class="keyword">if</span> (numElems &lt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(<span class="string">"Stack&lt;&gt;::top(): empty stack"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> elems[numElems<span class="number">-1</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<p>stack.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stack.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	Stack&lt;<span class="keyword">int</span>,<span class="number">20</span>&gt; stack_int;  <span class="comment">// 可以存储20个int元素的栈</span></div><div class="line">	Stack&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="number">40</span>&gt; stack_str; <span class="comment">// 可存储40个string元素的栈</span></div><div class="line"></div><div class="line">	<span class="comment">// 使用可存储20个int元素的栈</span></div><div class="line">	stack_int.push(<span class="number">7</span>);</div><div class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; stack_int.top() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    <span class="comment">//7</span></div><div class="line">	stack_int.pop();</div><div class="line"></div><div class="line">	<span class="comment">// 使用可存储40个string的栈</span></div><div class="line">	stack_str.push(<span class="string">"hello"</span>);</div><div class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; stack_str.top() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    <span class="comment">//hello</span></div><div class="line">	stack_str.pop();    </div><div class="line">	stack_str.pop();    <span class="comment">//Exception: Stack&lt;&gt;::pop&lt;&gt;: empty stack</span></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="模板的全特化和偏特化"><a href="#模板的全特化和偏特化" class="headerlink" title="模板的全特化和偏特化"></a>模板的全特化和偏特化</h2><p>所谓特化，就是将泛型的东西搞得具体化一些，从字面上来解释，就是为已有的模板参数进行一些使其特殊化的指定，使得以前不受任何约束的模板参数，或受到特定的修饰（例如const或者摇身一变成为了指针之类的东东，甚至是经过别的模板类包装之后的模板类型）或完全被指定了下来。</p>
<p>模板有两种特化，<strong>全特化</strong>和<strong>偏特化</strong>（局部特化） </p>
<ul>
<li>模板函数只能全特化，没有偏特化（以后可能有）。 </li>
<li>模板类是可以全特化和偏特化的。 </li>
</ul>
<p>全特化，就是模板中模板参数全被指定为确定的类型。全特化也就是定义了一个全新的类型，全特化的类中的函数可以与模板类不一样。 </p>
<p>偏特化，就是模板中的模板参数没有被全部确定，需要编译器在编译时进行确定。 在类型上加上const、&amp;、*（ cosnt int、int&amp;、int*、等等）并没有产生新的类型。只是类型被修饰了。模板在编译时，可以得到这些修饰信息。</p>
<p>模板为什么要特化，因为编译器认为，对于特定的类型，如果你能对某一功能更好的实现，那么就该听你的。<br>模板分为<strong>类模板</strong>与<strong>函数模板</strong>，特化分为<strong>全特化</strong>与<strong>偏特化</strong>。全特化就是限定死模板实现的具体类型，偏特化就是如果这个模板有多个类型，那么只限定其中的一部分。</p>
<p>先看类模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>  </span></div><div class="line">&#123;  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    Test(T1 i,T2 j):a(i),b(j)&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"模板类"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;  </div><div class="line"><span class="keyword">private</span>:  </div><div class="line">    T1 a;  </div><div class="line">    T2 b;  </div><div class="line">&#125;;  </div><div class="line">  </div><div class="line"><span class="keyword">template</span>&lt;&gt;  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;int , char&gt;  </span></div><div class="line">&#123;  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    Test(<span class="keyword">int</span> i, <span class="keyword">char</span> j):a(i),b(j)&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"全特化"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;  </div><div class="line"><span class="keyword">private</span>:  </div><div class="line">    <span class="keyword">int</span> a;  </div><div class="line">    <span class="keyword">char</span> b;  </div><div class="line">&#125;;  </div><div class="line">  </div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T2&gt;  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;char, T2&gt;  </span></div><div class="line">&#123;  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    Test(<span class="keyword">char</span> i, T2 j):a(i),b(j)&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"偏特化"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;  </div><div class="line"><span class="keyword">private</span>:  </div><div class="line">    <span class="keyword">char</span> a;  </div><div class="line">    T2 b;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>那么下面3句依次调用类模板、全特化与偏特化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Test&lt;<span class="keyword">double</span> , <span class="keyword">double</span>&gt; t1(<span class="number">0.1</span>,<span class="number">0.2</span>);  </div><div class="line">Test&lt;<span class="keyword">int</span> , <span class="keyword">char</span>&gt; t2(<span class="number">1</span>,<span class="string">'A'</span>);  </div><div class="line">Test&lt;<span class="keyword">char</span>, <span class="keyword">bool</span>&gt; t3(<span class="string">'A'</span>,<span class="literal">true</span>);</div></pre></td></tr></table></figure>
<p>而对于函数模板，却只有全特化，不能偏特化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//模板函数  </span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(T1 a , T2 b)</span>  </span></div><div class="line">&#123;  </div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"模板函数"</span>&lt;&lt;<span class="built_in">endl</span>;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="comment">//全特化  </span></div><div class="line"><span class="keyword">template</span>&lt;&gt;  </div><div class="line"><span class="keyword">void</span> fun&lt;<span class="keyword">int</span> ,<span class="keyword">char</span> &gt;(<span class="keyword">int</span> a, <span class="keyword">char</span> b)  </div><div class="line">&#123;  </div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"全特化"</span>&lt;&lt;<span class="built_in">endl</span>;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="comment">//函数不存在偏特化：下面的代码是错误的  </span></div><div class="line"><span class="comment">/* </span></div><div class="line">template&lt;typename T2&gt; </div><div class="line">void fun&lt;char,T2&gt;(char a, T2 b) </div><div class="line">&#123; </div><div class="line">    cout&lt;&lt;"偏特化"&lt;&lt;endl; </div><div class="line">&#125; </div><div class="line">*/</div></pre></td></tr></table></figure>
<p>至于为什么函数不能偏特化，似乎不是因为语言实现不了，而是因为偏特化的功能可以通过函数的重载完成。</p>
<p>函数模版的全特化不参与函数重载, 并且优先级低于函数基础模版参与匹配，也就是说，匹配的顺序是：</p>
<ol>
<li>非模板函数</li>
<li>某个没有进行全特化的template function</li>
<li>如果这个没有进行全特化的template function有全特化版本，并且类型也比较匹配，则选择这个全特化版本</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/25/CppS2_2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Oizys">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/o1zys">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Oizys's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/25/CppS2_2/" itemprop="url">C++ Section2 面向对象(2) 多态与虚函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-25T19:07:19+08:00">
                2017-12-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/" itemprop="url" rel="index">
                    <span itemprop="name">cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/12/25/CppS2_2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/12/25/CppS2_2/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h2><p>多态指当不同的对象收到相同的消息时，产生不同的动作</p>
<ul>
<li>编译时多态（静态绑定），函数重载，运算符重载，模板。</li>
<li>运行时多态（动态绑定），虚函数机制。</li>
</ul>
<h2 id="运行时多态（动态绑定）"><a href="#运行时多态（动态绑定）" class="headerlink" title="运行时多态（动态绑定）"></a>运行时多态（动态绑定）</h2><ul>
<li>定义：“一个接口，多种方法”，程序在运行时才决定调用的函数。</li>
<li>实现：C++多态性主要是通过虚函数实现的，虚函数允许子类重写override(注意和overload的区别，overload是重载，是允许同名函数的表现，这些函数参数列表/类型不同）。</li>
<li>目的：接口重用。封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了接口重用。</li>
<li>用法：声明基类的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，可以根据指向的子类的不同而实现不同的方法。</li>
</ul>
<h2 id="重载、覆盖、重写的区别"><a href="#重载、覆盖、重写的区别" class="headerlink" title="重载、覆盖、重写的区别"></a>重载、覆盖、重写的区别</h2><ul>
<li><p>Overload(重载)：</p>
<p>  在C++程序中，可以将语义、功能相似的几个函数用同一个名字表示，但参数或返回值不同（包括类型、顺序不同），即函数重载。</p>
<p>  （1）相同的范围（在同一个类中）；<br>  （2）函数名字相同；<br>  （3）参数不同；<br>  （4）virtual 关键字可有可无。</p>
</li>
</ul>
<ul>
<li><p>Override(覆盖)：</p>
<p>  是指派生类函数覆盖基类函数，特征是：</p>
<p>  （1）不同的范围（分别位于派生类与基类）；<br>  （2）函数名字相同；<br>  （3）参数相同；<br>  （4）基类函数必须有virtual 关键字。</p>
</li>
<li><p>Overwrite(重写)：</p>
<p>  即隐藏，是指派生类的函数屏蔽了与其同名的基类函数，规则如下：</p>
<p>  （1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。<br>  （2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被重写(隐藏)（注意别与覆盖混淆）。</p>
</li>
</ul>
<p><strong>注：重写基类虚函数的时候，会自动转换这个函数为virtual函数，不管有没有加virtual，因此重写的时候不加virtual也是可以的，不过为了易读性，还是加上比较好。</strong></p>
<h2 id="虚函数与虚继承"><a href="#虚函数与虚继承" class="headerlink" title="虚函数与虚继承"></a>虚函数与虚继承</h2><blockquote>
<p>转自：<a href="http://www.cnblogs.com/fanzhidongyzby/archive/2013/01/14/2859064.html" target="_blank" rel="noopener">虚函数与虚继承寻踪</a></p>
</blockquote>
<h3 id="基本对象模型"><a href="#基本对象模型" class="headerlink" title="基本对象模型"></a>基本对象模型</h3><p>首先，我们定义一个简单的类，它含有一个数据成员和一个虚函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> var;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></div><div class="line">    &#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>编译出的<code>MyClass</code>对象结构如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">1&gt;  class MyClass    size(8):</div><div class="line">1&gt;      +---</div><div class="line">1&gt;   0    | &#123;vfptr&#125;</div><div class="line">1&gt;   4    | var</div><div class="line">1&gt;      +---</div><div class="line">1&gt;  </div><div class="line">1&gt;  MyClass::$vftable@:</div><div class="line">1&gt;      | &amp;MyClass_meta</div><div class="line">1&gt;      |  0</div><div class="line">1&gt;   0    | &amp;MyClass::fun</div><div class="line">1&gt;  </div><div class="line">1&gt;  MyClass::fun this adjustor: 0</div></pre></td></tr></table></figure>
<p>从这段信息中我们看出，<code>MyClass</code>对象大小是8个字节。前四个字节存储的是虚函数表的指针<code>vfptr</code>，后四个字节存储对象成员<code>var</code>的值。虚函数表的大小为4字节，就一条函数地址，即虚函数<code>fun</code>的地址，它在虚函数表<code>vftable</code>的偏移是0。因此，MyClass对象模型的结果如图1所示。</p>
<center> <img src="https://raw.githubusercontent.com/o1zys/MarkdownImage/master/cpp_s2_2_1.jpg" alt="图1 Myclass对象模型"> </center>

<center>图1 MyClass 对象模型</center>


<p><code>MyClass</code>的虚函数表虽然只有一条函数记录，但是它的结尾处是由4字节的0作为结束标记的。<br>adjust表示虚函数机制执行时，this指针的调整量，假如fun被多态调用的话，那么它的形式如下：</p>
<pre><code>*(this+0)[0]()
</code></pre><p>总结虚函数调用形式，应该是：</p>
<pre><code>*(this指针+调整量)[虚函数在vftable内的偏移]()
</code></pre><h3 id="单重继承对象模型"><a href="#单重继承对象模型" class="headerlink" title="单重继承对象模型"></a>单重继承对象模型</h3><p>我们定义一个继承于<code>MyClass</code>类的子类<code>MyClassA</code>，它重写了<code>fun</code>函数，并且提供了一个新的虚函数<code>funA</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClassA</span> :</span> <span class="keyword">public</span> MyClass &#123;</div><div class="line">    <span class="keyword">int</span> varA;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></div><div class="line">    &#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funA</span><span class="params">()</span></span></div><div class="line">    &#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>它的对象模型为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">1&gt;  class MyClassA    size(12):</div><div class="line">1&gt;      +---</div><div class="line">1&gt;      | +--- (base class MyClass)</div><div class="line">1&gt;   0    | | &#123;vfptr&#125;</div><div class="line">1&gt;   4    | | var</div><div class="line">1&gt;      | +---</div><div class="line">1&gt;   8    | varA</div><div class="line">1&gt;      +---</div><div class="line">1&gt;  </div><div class="line">1&gt;  MyClassA::$vftable@:</div><div class="line">1&gt;      | &amp;MyClassA_meta</div><div class="line">1&gt;      |  0</div><div class="line">1&gt;   0    | &amp;MyClassA::fun</div><div class="line">1&gt;   1    | &amp;MyClassA::funA</div><div class="line">1&gt;  </div><div class="line">1&gt;  MyClassA::fun this adjustor: 0</div><div class="line">1&gt;  MyClassA::funA this adjustor: 0</div></pre></td></tr></table></figure>
<p>可以看出，<code>MyClassA</code>将基类<code>MyClass</code>完全包含在自己内部，包括<code>vfptr</code>和<code>var</code>。并且虚函数表内的记录多了一条——<code>MyClassA</code>自己定义的虚函数<code>funA</code>。它的对象模型如图2所示。</p>
<center> <img src="https://raw.githubusercontent.com/o1zys/MarkdownImage/master/cpp_s2_2_2.jpg" alt="图2 MyclassA对象模型"> </center>

<center>图2 MyClassA 对象模型</center>

<p>我们可以得出结论：</p>
<ul>
<li>在单继承形式下，子类完全获得父类的虚函数表和数据。</li>
<li>子类如果重写了父类的虚函数（如<code>fun</code>），就会把虚函数表原本<code>fun</code>对应的记录（内容<code>MyClass::fun</code>）覆盖为新的函数地址（内容<code>MyClassA::fun</code>），否则继续保持原本的函数地址记录。</li>
<li>如果子类定义了新的虚函数，虚函数表内会追加一条记录，记录该函数的地址（如<code>MyClassA::funA</code>）。</li>
</ul>
<p>另外类的非虚成员排列顺序是由基类到派生类，先<code>var</code>再<code>varA</code>。</p>
<p>使用这种方式，就可以实现多态的特性。假设我们使用如下语句：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">MyClass*pc = <span class="keyword">new</span> MyClassA;</div><div class="line">pc-&gt;fun();</div></pre></td></tr></table></figure>
<p>编译器在处理第二条语句时，发现这是一个多态的调用，那么就会按照上边我们对虚函数的多态访问机制调用函数<code>fun</code>。</p>
<pre><code>*(pc+0)[0]()
</code></pre><p>因为虚函数表内的函数地址已经被子类重写的<code>fun</code>函数地址覆盖了，因此该处调用的函数正是<code>MyClassA::fun</code>，而不是基类的<code>MyClass::fun</code>。</p>
<p>如果使用<code>MyClassA</code>对象直接访问<code>fun</code>，则不会出发多态机制，因为这个函数调用在编译时期是可以确定的，编译器只需要直接调用<code>MyClassA::fun</code>即可。</p>
<h3 id="多重继承对象模型"><a href="#多重继承对象模型" class="headerlink" title="多重继承对象模型"></a>多重继承对象模型</h3><p>和前边<code>MyClassA</code>类似，我们也定义一个类<code>MyClassB</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClassB</span> :</span> <span class="keyword">public</span> MyClass &#123;</div><div class="line">    <span class="keyword">int</span> varB;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></div><div class="line">    &#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funB</span><span class="params">()</span></span></div><div class="line">    &#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>它的对象模型和<code>MyClassA</code>完全类似，这里就不再赘述了。</p>
<p>为了实现多重继承，我们再定义一个类<code>MyClassC</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClassC</span> :</span> <span class="keyword">public</span> MyClassA, <span class="keyword">public</span> MyClassB &#123;</div><div class="line">    <span class="keyword">int</span> varC;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funB</span><span class="params">()</span></span></div><div class="line">   &#123;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funC</span><span class="params">()</span></span></div><div class="line">   &#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>为了简化，我们让<code>MyClassC</code>只重写父类<code>MyClassB</code>的虚函数<code>funB</code>，它的对象模型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">1&gt;  class MyClassC    size(28):</div><div class="line">1&gt;      +---</div><div class="line">1&gt;      | +--- (base class MyClassA)</div><div class="line">1&gt;      | | +--- (base class MyClass)</div><div class="line">1&gt;   0    | | | &#123;vfptr&#125;</div><div class="line">1&gt;   4    | | | var</div><div class="line">1&gt;      | | +---</div><div class="line">1&gt;   8    | | varA</div><div class="line">1&gt;      | +---</div><div class="line">1&gt;      | +--- (base class MyClassB)</div><div class="line">1&gt;      | | +--- (base class MyClass)</div><div class="line">1&gt;  12    | | | &#123;vfptr&#125;</div><div class="line">1&gt;  16    | | | var</div><div class="line">1&gt;      | | +---</div><div class="line">1&gt;  20    | | varB</div><div class="line">1&gt;      | +---</div><div class="line">1&gt;  24    | varC</div><div class="line">1&gt;      +---</div><div class="line">1&gt;  </div><div class="line">1&gt;  MyClassC::$vftable@MyClassA@:</div><div class="line">1&gt;      | &amp;MyClassC_meta</div><div class="line">1&gt;      |  0</div><div class="line">1&gt;   0    | &amp;MyClassA::fun</div><div class="line">1&gt;   1    | &amp;MyClassA::funA</div><div class="line">1&gt;   2    | &amp;MyClassC::funC</div><div class="line">1&gt;  </div><div class="line">1&gt;  MyClassC::$vftable@MyClassB@:</div><div class="line">1&gt;      | -12</div><div class="line">1&gt;   0    | &amp;MyClassB::fun</div><div class="line">1&gt;   1    | &amp;MyClassC::funB</div><div class="line">1&gt;  </div><div class="line">1&gt;  MyClassC::funB this adjustor: 12</div><div class="line">1&gt;  MyClassC::funC this adjustor: 0</div></pre></td></tr></table></figure>
<p>和单重继承类似，多重继承时<code>MyClassC</code>会把所有的父类全部按序包含在自身内部。而且每一个父类都对应一个单独的虚函数表。<code>MyClassC</code>的对象模型如图3所示。</p>
<center> <img src="https://raw.githubusercontent.com/o1zys/MarkdownImage/master/cpp_s2_2_3.jpg" alt="图3 MyclassC对象模型"> </center>

<center>图3 MyClassC 对象模型</center>


<p>多重继承下，子类不再具有自身的虚函数表，它的虚函数表与第一个父类的虚函数表<strong>合并</strong>了。</p>
<p>同样的，如果子类重写了任意父类的虚函数，都会覆盖对应的函数地址记录。如果<code>MyClassC</code>重写了<code>fun</code>函数（两个父类都有该函数），那么两个虚函数表的记录都需要被覆盖！</p>
<p>在这里我们发现<code>MyClassC::funB</code>的函数对应的adjust值是12，按照我们前边的规则，可以发现该函数的多态调用形式为：</p>
<pre><code>*(this+12)[1]()
</code></pre><p>此处的调整量12正好是<strong><code>MyClassB</code>的<code>vfptr</code>在<code>MyClassC</code>对象内的偏移量</strong>。</p>
<h3 id="虚拟继承对象模型"><a href="#虚拟继承对象模型" class="headerlink" title="虚拟继承对象模型"></a>虚拟继承对象模型</h3><p>虚拟继承是为了解决多重继承下公共基类的多份拷贝问题。比如上边的例子中<code>MyClassC</code>的对象内包含<code>MyClassA</code>和<code>MyClassB</code>子对象，但是<code>MyClassA</code>和<code>MyClassB</code>内含有共同的基类<code>MyClass</code>。为了消除<code>MyClass</code>子对象的多份存在，我们需要让<code>MyClassA</code>和<code>MyClassB</code>都虚拟继承于<code>MyClass</code>，然后再让<code>MyClassC</code>多重继承于这两个父类。相对于上边的例子，类内的设计不做任何改动，先修改MyClassA和MyClassB的继承方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClassA</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> MyClass</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClassB</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> MyClass</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClassC</span> :</span> <span class="keyword">public</span> MyClassA, <span class="keyword">public</span> MyClassB</div></pre></td></tr></table></figure>
<p>由于虚继承的本身语义，<code>MyClassC</code>内必须重写<code>fun</code>函数，否则由于同时存在<code>MyClassA::fun</code>和<code>MyClassB::fun</code>，会有二义性。因此我们需要再重写<code>fun</code>函数。这种情况下，MyClassC的对象模型如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">1&gt;  class MyClassC    size(36):</div><div class="line">1&gt;      +---</div><div class="line">1&gt;      | +--- (base class MyClassA)</div><div class="line">1&gt;   0    | | &#123;vfptr&#125;</div><div class="line">1&gt;   4    | | &#123;vbptr&#125;</div><div class="line">1&gt;   8    | | varA</div><div class="line">1&gt;      | +---</div><div class="line">1&gt;      | +--- (base class MyClassB)</div><div class="line">1&gt;  12    | | &#123;vfptr&#125;</div><div class="line">1&gt;  16    | | &#123;vbptr&#125;</div><div class="line">1&gt;  20    | | varB</div><div class="line">1&gt;      | +---</div><div class="line">1&gt;  24    | varC</div><div class="line">1&gt;      +---</div><div class="line">1&gt;      +--- (virtual base MyClass)</div><div class="line">1&gt;  28    | &#123;vfptr&#125;</div><div class="line">1&gt;  32    | var</div><div class="line">1&gt;      +---</div><div class="line">1&gt;  </div><div class="line">1&gt;  MyClassC::$vftable@MyClassA@:</div><div class="line">1&gt;      | &amp;MyClassC_meta</div><div class="line">1&gt;      |  0</div><div class="line">1&gt;   0    | &amp;MyClassA::funA</div><div class="line">1&gt;   1    | &amp;MyClassC::funC</div><div class="line">1&gt;  </div><div class="line">1&gt;  MyClassC::$vftable@MyClassB@:</div><div class="line">1&gt;      | -12</div><div class="line">1&gt;   0    | &amp;MyClassC::funB</div><div class="line">1&gt;  </div><div class="line">1&gt;  MyClassC::$vbtable@MyClassA@:</div><div class="line">1&gt;   0    | -4</div><div class="line">1&gt;   1    | 24 (MyClassCd(MyClassA+4)MyClass)</div><div class="line">1&gt;  </div><div class="line">1&gt;  MyClassC::$vbtable@MyClassB@:</div><div class="line">1&gt;   0    | -4</div><div class="line">1&gt;   1    | 12 (MyClassCd(MyClassB+4)MyClass)</div><div class="line">1&gt;  </div><div class="line">1&gt;  MyClassC::$vftable@MyClass@:</div><div class="line">1&gt;      | -28</div><div class="line">1&gt;   0    | &amp;MyClassC::fun</div><div class="line">1&gt;  </div><div class="line">1&gt;  MyClassC::fun this adjustor: 28</div><div class="line">1&gt;  MyClassC::funB this adjustor: 12</div><div class="line">1&gt;  MyClassC::funC this adjustor: 0</div><div class="line">1&gt;  </div><div class="line">1&gt;  vbi:       class  offset o.vbptr  o.vbte fVtorDisp</div><div class="line">1&gt;           MyClass      28       4       4 0</div></pre></td></tr></table></figure>
<p>虚继承的引入把对象的模型变得十分复杂，除了每个基类（<code>MyClassA</code>和<code>MyClassB</code>）和公共基类（<code>MyClass</code>）的虚函数表指针需要记录外，每个虚拟继承了<code>MyClass</code>的父类还需要记录一个虚基类表<code>vbtable</code>的指针<code>vbptr</code>。<code>MyClassC</code>的对象模型如图4所示。</p>
<center> <img src="https://raw.githubusercontent.com/o1zys/MarkdownImage/master/cpp_s2_2_4.jpg" alt="图4 MyclassC虚继承对象模型"> </center>

<center>图4 MyClassC 虚继承对象模型]</center>


<p>虚基类表的第一项记录着当前子对象（当前虚表指针，<code>vfptr_A</code>或者<code>vfptr_B</code>）相对与当前虚基类表指针（<code>vbptr_A</code>或者<code>vbptr_B</code>）的偏移。</p>
<p><code>MyClassA</code>和<code>MyClassB</code>子对象内的虚表指针都是存储在相对于自身的4字节偏移处，因此该值是-4。假定<code>MyClassA</code>和<code>MyClassC</code>或者<code>MyClassB</code>内没有定义新的虚函数，即不会产生虚函数表，那么虚基类表第一项字段的值应该是0。</p>
<p>虚基类表的第二项记录着公共基类虚表指针<code>vfptr</code>相对于当前虚基类表指针（<code>vbptr_A</code>或者<code>vbptr_B</code>）的偏移量。</p>
<p>比如<code>MyClassA</code>的虚基类表第二项记录值为24，正是<code>MyClass::vfptr</code>相对于<code>MyClassA::vbptr</code>的偏移量，同理<code>MyClassB</code>的虚基类表第二项记录值12也正是<code>MyClass::vfptr</code>相对于<code>MyClassA::vbptr</code>的偏移量。</p>
<p>通过以上的对象组织形式，编译器解决了公共虚基类的多份拷贝的问题。通过每个父类的虚基类表指针，都能找到被公共使用的虚基类的子对象的位置，并依次访问虚基类子对象的数据。至于虚基类定义的虚函数，它和其他的虚函数的访问形式相同，本例中，如果使用虚基类指针<code>MyClass*pc</code>访问<code>MyClassC</code>对象的<code>fun</code>，将会被转化为如下形式：</p>
<pre><code>*(pc+28)[0]()
</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>虚函数机制涉及的指针和表有:</p>
<ul>
<li>虚函数表指针<code>vfptr</code>和虚函数表<code>vftable</code></li>
<li>虚继承下还涉及 虚基类表指针<code>vbptr</code>和虚基类表<code>vbtable</code></li>
</ul>
<p>虚函数的实现过程：</p>
<ol>
<li>编译器为每个含有虚函数的类或者从此类派生的类创建一个虚函数表<code>vftable</code>, 保存此类所有虚函数的地址，并增加一个隐藏成员虚函数表指针<code>vfptr</code>放在所有数据成员之前。在创建类的对象时，在构造函数内部对虚函数表指针进行初始化，指向之前创建的虚函数表。</li>
<li><strong>单继承情况下</strong>，派生类会继承基类所有的数据成员和虚函数表指针，并由编译器生成虚函数表，在创建派生类实例时，将虚函数表指针指向新的，属于派生类的虚函数表。</li>
<li><strong>多重继承情况下</strong>，会有多个虚函数表，几重继承，就会有几个虚函数表。这些表按照派生的顺序依次排列，如果派生类改写了基类的虚函数，那么就会用派生类自己的虚函数覆盖虚函数表的相应的位置，如果派生类有新的虚函数，那么就添加到第一个虚函数表的末尾。</li>
<li><strong>虚继承情况下</strong>，会再创建一个<strong>虚基类表</strong>和一个<strong>虚基类表指针</strong>，也就是说，编译器会增加两个指针，<ul>
<li>一个是<strong>虚基类表指针</strong>，指向<strong>虚基类表</strong>，保存了所有继承过来的虚基类在内存中的地址（偏移量）；</li>
<li>另一个是从公共基类（<code>MyClass</code>）继承过来的<strong>虚函数表指针</strong>，保存了公共基类<strong>虚函数</strong>的地址。</li>
</ul>
</li>
<li>虚基类部分会在C++继承层次中只有一份。所有由虚基类派生的类都持有一个虚基类表指针，指向一个虚基类表，表里面保存了所有它继承的虚基类部分的地址。虚基类部分有一个虚函数表指针，指向虚函数表。</li>
</ol>
<h2 id="基类的析构函数为什么要声明为虚函数"><a href="#基类的析构函数为什么要声明为虚函数" class="headerlink" title="基类的析构函数为什么要声明为虚函数"></a>基类的析构函数为什么要声明为虚函数</h2><p>为了能在多态情况下准确调用派生类的析构函数。</p>
<p>如果基类的析构函数非虚函数，则用基类指针或引用引用派生类进行析构时，只会调用基类的析构函数；如果是虚析构函数，则会依次调用派生类的析构和基类的析构。（基类的析构是一定会调用的，无论是否为虚）。</p>
<h2 id="构造函数为什么不可以是虚函数"><a href="#构造函数为什么不可以是虚函数" class="headerlink" title="构造函数为什么不可以是虚函数"></a>构造函数为什么不可以是虚函数</h2><p>虚函数在运行期决定函数调用，而在构造一个对象时，由于对象还未构造成功，编译器无法确定对象的实际类型，继而无法决定调用哪一个构造函数。</p>
<p>虚函数的执行依赖于虚函数表，而虚函数表在构造函数中进行初始化工作，即初始化 <code>vptr</code>，让它指向正确的虚函数表，而在构造期间，虚函数表还没有初始化，所以无法决定调用哪个构造函数。</p>
<p>所以，非纯虚的虚方法也就是普通的虚方法必须写定义，哪怕是空的，因为要生成虚函数表，没有方法定义就没有方法地址。纯虚方法和非虚方法可以不用写定义。</p>
<h2 id="不能声明为虚函数的成员函数"><a href="#不能声明为虚函数的成员函数" class="headerlink" title="不能声明为虚函数的成员函数"></a>不能声明为虚函数的成员函数</h2><p><strong>构造函数</strong>：</p>
<p>首先明确一点，在编译期间编译器完成了虚表的创建，而虚指针在构造函数期间被初始化。<br>如果构造函数是虚函数，那必然需要通过虚指针来找到虚构造函数的入口地址，但是这个时候我们还没有把虚指针初始化。因此，构造函数不能是虚函数。</p>
<p><strong>內联函数</strong>：</p>
<p>编译期內联函数在调用处被展开，而虚函数在运行时才能被确定具体调用哪个类的虚函数。內联函数体现的是编译期机制，而虚函数体现的是运行期机制。</p>
<p><strong>静态成员函数</strong>:</p>
<p>静态成员函数和类有关，即使没有生成一个实例对象，也可以调用类的静态成员函数。而虚函数的调用和虚指针有关，虚指针存在于一个类的实例对象中，如果静态成员函数被声明成虚函数，那么调用成员静态函数时又如何访问虚指针呢。总之可以这么理解，静态成员函数与类有关，而虚函数与类的实例对象有关。</p>
<p><strong>非成员函数</strong>:</p>
<p>虚函数的目的是为了实现多态，多态和继承有关。所以声明一个非成员函数为虚函数没有任何意义。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/25/CppS2_1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Oizys">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/o1zys">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Oizys's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/25/CppS2_1/" itemprop="url">C++ Section2 面向对象(1)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-25T19:07:02+08:00">
                2017-12-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/" itemprop="url" rel="index">
                    <span itemprop="name">cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/12/25/CppS2_1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/12/25/CppS2_1/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h2><p>三大特性：封装，继承，多态。</p>
<ol>
<li>封装：封装是实现面向对象程序设计的第一步，封装就是将数据或函数等集合在一个个的单元中（我们称之为类）。封装的意义在于保护或者防止代码（数据）被我们无意中破坏。</li>
<li>继承：继承主要实现重用代码，节省开发时间。子类可以继承父类的一些东西。</li>
<li>多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。分为编译时多态和运行时多态。</li>
</ol>
<h2 id="可被继承及不可被继承"><a href="#可被继承及不可被继承" class="headerlink" title="可被继承及不可被继承"></a>可被继承及不可被继承</h2><p>无法被继承的有:  </p>
<ul>
<li>构造函数</li>
<li>析构函数</li>
<li>赋值运算符</li>
<li>友元函数</li>
</ul>
<p>可被继承的有:</p>
<ul>
<li>静态成员</li>
<li>静态方法</li>
<li>非静态成员</li>
<li>非静态方法</li>
<li>虚表指针</li>
</ul>
<h2 id="定义默认构造函数的两种方法"><a href="#定义默认构造函数的两种方法" class="headerlink" title="定义默认构造函数的两种方法"></a>定义默认构造函数的两种方法</h2><ul>
<li>给已有的构造函数中的一个的所有参数加上默认值</li>
<li>通过方法重载定义一个无参数构造函数</li>
</ul>
<p><strong>注意：隐式调用默认构造函数不要加括号(), 会被编译器解释为函数声明。</strong></p>
<h2 id="调用非默认构造函数的三种方法"><a href="#调用非默认构造函数的三种方法" class="headerlink" title="调用非默认构造函数的三种方法"></a>调用非默认构造函数的三种方法</h2><ol>
<li>Foo f(…); // 隐式调用</li>
<li>Foo f = Foo(…) ;// 显式调用</li>
<li>Foo* f = new Foo(); // 显式调用 </li>
</ol>
<h2 id="由编译器生成的六个成员函数"><a href="#由编译器生成的六个成员函数" class="headerlink" title="由编译器生成的六个成员函数"></a>由编译器生成的六个成员函数</h2><ol>
<li>默认构造函数</li>
<li>析构函数</li>
<li>复制构造函数</li>
<li>赋值运算符</li>
<li>取地址运算符</li>
<li>取地址运算符 const版本</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">	Foo();                              <span class="comment">// 默认构造函数</span></div><div class="line">	~Foo();                             <span class="comment">// 析构函数</span></div><div class="line">	Foo(<span class="keyword">const</span> Foo &amp;);                   <span class="comment">// 复制构造函数</span></div><div class="line">	<span class="keyword">const</span> Foo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Foo &amp;);  <span class="comment">// 赋值构造函数</span></div><div class="line">	Foo* <span class="keyword">operator</span>&amp;();                   <span class="comment">// 取地址运算符</span></div><div class="line">	<span class="keyword">const</span> Foo* <span class="keyword">operator</span>&amp;() <span class="keyword">const</span>;       <span class="comment">// 取地址运算符const重载</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="必须在构造函数初始化式里进行初始化的数据成员"><a href="#必须在构造函数初始化式里进行初始化的数据成员" class="headerlink" title="必须在构造函数初始化式里进行初始化的数据成员"></a>必须在构造函数初始化式里进行初始化的数据成员</h2><ol>
<li>常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面</li>
<li>引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面</li>
<li>没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化</li>
</ol>
<h2 id="如果赋值构造函数参数不是传引用而是传值会有什么问题？"><a href="#如果赋值构造函数参数不是传引用而是传值会有什么问题？" class="headerlink" title="如果赋值构造函数参数不是传引用而是传值会有什么问题？"></a>如果赋值构造函数参数不是传引用而是传值会有什么问题？</h2><p>如果不是传引用，会造成栈溢出。因为如果是Foo(Foo f)的形式，实参初始化形参的时候也会调用复制构造函数，造成死循环。所以，复制构造函数一定要传引用：</p>
<p>Foo(Foo&amp; f); </p>
<h2 id="三种继承方式（public-private-protected）的区别"><a href="#三种继承方式（public-private-protected）的区别" class="headerlink" title="三种继承方式（public, private, protected）的区别"></a>三种继承方式（public, private, protected）的区别</h2><ol>
<li><p><strong>公有继承（public）:</strong> </p>
<ul>
<li><strong>基类成员对其对象的可见性</strong>: 与一般类及其对象的可见性相同，<strong>public</strong>成员可见，<strong>protected</strong>和<strong>private</strong>成员不可见。  </li>
<li><strong>基类成员对派生类的可见性</strong>: 对派生类来说，基类的 <strong>public</strong> 和 <strong>protected</strong> 成员可见的。<ul>
<li>基类的 <strong>public</strong> 成员和 <strong>protected</strong> 成员作为派生类的成员时，它们都保持原有状态；</li>
<li>基类的 <strong>private</strong> 成员依旧是private，派生类不可访问基类中的private成员。  </li>
</ul>
</li>
<li><strong>基类成员对派生类对象的可见性</strong>: 对派生类对象来说，基类的public成员是可见的，其他成员是不可见的。所以，在公有继承时，<strong>派生类的对象</strong>可以访问基类中的public成员，<strong>派生类的成员方法</strong>可以访问基类中的public成员和protected成员。</li>
</ul>
</li>
<li><p><strong>私有继承（private）:</strong> </p>
<ul>
<li><strong>基类成员对其对象的可见性</strong>: 与一般类及其对象的可见性相同，public成员可见，其他成员不可见。  </li>
<li><strong>基类成员对派生类的可见性</strong>: 对派生类来说，基类的public和protected成员可见：<ul>
<li>基类的 <strong>public</strong> 成员和 <strong>protected</strong> 成员都作为派生类的 <strong>private</strong> 成员，并且不能被这个派生类的子类所访问；</li>
<li>基类的 <strong>private</strong> 成员依旧是private，派生类不可访问基类中的private成员。</li>
</ul>
</li>
<li><strong>基类成员对派生类对象的可见性</strong>: 对派生类对象来说，基类的所有成员都是不可见的,所以在私有继承时，基类的成员只能由直接派生类访问，<strong>无法再往下继承</strong>。</li>
</ul>
</li>
<li><p><strong>保护继承（protected）:</strong> </p>
<ul>
<li>保护继承与私有继承相似，基类成员对其对象的可见性与一般类及其对象的可见性相同，public成员可见，其他成员不可见。</li>
<li><strong>基类成员对派生类的可见性</strong>: 对派生类来说，基类的public和protected成员是可见的：<ul>
<li>基类的 <strong>public</strong> 成员和 <strong>protected</strong> 成员都作为派生类的 <strong>protected</strong> 成员，并且不能被这个派生类的子类所访问；</li>
<li>基类的 <strong>private</strong> 成员依旧是private，派生类不可访问基类中的private成员。</li>
</ul>
</li>
<li><strong>基类成员对派生类对象的可见性</strong>: 对派生类对象来说，基类的所有成员都是不可见的。所以，在保护继承时，基类的成员也只能由直接派生类访问，而<strong>无法再向下继承</strong>。</li>
</ul>
</li>
</ol>
<p>C++支持多重继承。多重继承是一个类从多个基类派生而来的能力。派生类实际上获取了所有基类的特性。当一个类 是两个或多个基类的派生类时，派生类的构造函数必须激活所有基类的构造函数，并把相应的参数传递给它们 。</p>
<h2 id="class-与-struct的区别"><a href="#class-与-struct的区别" class="headerlink" title="class 与 struct的区别"></a>class 与 struct的区别</h2><ul>
<li>class默认的继承方式为private, struct 默认继承方式为public </li>
<li>class的成员访问默认为private, struct默认为public </li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/25/CppS1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Oizys">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/o1zys">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Oizys's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/25/CppS1/" itemprop="url">C++ Section1 关键字及其用法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-25T19:06:41+08:00">
                2017-12-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/" itemprop="url" rel="index">
                    <span itemprop="name">cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/12/25/CppS1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/12/25/CppS1/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><h3 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h3><h4 id="限定符声明变量只能被读"><a href="#限定符声明变量只能被读" class="headerlink" title="限定符声明变量只能被读"></a>限定符声明变量只能被读</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> i=<span class="number">5</span>; </div><div class="line"><span class="keyword">int</span> j=<span class="number">0</span>; </div><div class="line">... </div><div class="line">i=j;  <span class="comment">//非法，导致编译错误 </span></div><div class="line">j=i;  <span class="comment">//合法</span></div></pre></td></tr></table></figure>
<h4 id="必须初始化"><a href="#必须初始化" class="headerlink" title="必须初始化"></a>必须初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> i=<span class="number">5</span>;    <span class="comment">//合法 </span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> j;      <span class="comment">//非法，导致编译错误</span></div></pre></td></tr></table></figure>
<h4 id="在另一连接文件中引用const常量"><a href="#在另一连接文件中引用const常量" class="headerlink" title="在另一连接文件中引用const常量"></a>在另一连接文件中引用const常量</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> i;    <span class="comment">//合法 </span></div><div class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> j=<span class="number">10</span>; <span class="comment">//非法，常量不可以被再次赋值</span></div></pre></td></tr></table></figure>
<h4 id="便于进行类型检查"><a href="#便于进行类型检查" class="headerlink" title="便于进行类型检查"></a>便于进行类型检查</h4><p>用const方法可以使编译器对处理内容有更多了解。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> I=10 </span></div><div class="line"><span class="keyword">const</span> <span class="keyword">long</span> &amp;i=<span class="number">10</span>;  <span class="comment">/*：由于编译器的优化，使 </span></div><div class="line">      得在const long i=10; 时i不被分配内存，而是已10直接代入 </div><div class="line">      以后的引用中，以致在以后的代码中没有错误，为达到说教效 </div><div class="line">      果，特别地用&amp;i明确地给出了i的内存分配。不过一旦你关闭所 </div><div class="line">      有优化措施，即使const long i=10;也会引起后面的编译错误。*/ </div><div class="line"><span class="keyword">char</span> h=I;      <span class="comment">//没有错 </span></div><div class="line"><span class="keyword">char</span> h=i;      <span class="comment">//编译警告，可能由于数的截短带来错误赋值。</span></div></pre></td></tr></table></figure>
<h4 id="可以避免不必要的内存分配"><a href="#可以避免不必要的内存分配" class="headerlink" title="可以避免不必要的内存分配"></a>可以避免不必要的内存分配</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> STRING <span class="meta-string">"abcdefghijklmn\n"</span> </span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> <span class="built_in">string</span>[]=<span class="string">"abcdefghijklm\n"</span>; </div><div class="line">... </div><div class="line"><span class="built_in">printf</span>(STRING);  <span class="comment">//为STRING分配了第一次内存 </span></div><div class="line"><span class="built_in">printf</span>(<span class="built_in">string</span>);  <span class="comment">//为string一次分配了内存，以后不再分配 </span></div><div class="line">... </div><div class="line"><span class="built_in">printf</span>(STRING);  <span class="comment">//为STRING分配了第二次内存 </span></div><div class="line"><span class="built_in">printf</span>(<span class="built_in">string</span>);</div></pre></td></tr></table></figure>
<p>由于const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象#define一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝，而#define定义的常量在内存中有若干个拷贝。</p>
<h4 id="可以通过函数对常量进行初始化"><a href="#可以通过函数对常量进行初始化" class="headerlink" title="可以通过函数对常量进行初始化"></a>可以通过函数对常量进行初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>; </div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = value();</div></pre></td></tr></table></figure>
<p>假定对ROM编写程序时，由于目标代码的不可改写，本语句将会无效，不过可以变通一下： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;i=value();</div></pre></td></tr></table></figure>
<p>只要令i的地址处于ROM之外，即可实现：i通过函数初始化，而其值有不会被修改。 </p>
<h4 id="const的常量值可以被修改"><a href="#const的常量值可以被修改" class="headerlink" title="const的常量值可以被修改"></a>const的常量值可以被修改</h4><p>观察以下一段代码： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">0</span>; </div><div class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span>*)&amp;i; </div><div class="line">p = <span class="number">100</span>;</div></pre></td></tr></table></figure>
<p>通过强制类型转换，将地址赋给变量，再作修改即可以改变const常量值。 </p>
<h4 id="const与指针"><a href="#const与指针" class="headerlink" title="const与指针"></a>const与指针</h4><p>const char *p 表示 指向的内容不能改变。</p>
<p>char * const p，就是将P声明为常指针，它的地址不能改变，是固定的，但是它的内容可以改变。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> ii=<span class="number">0</span>; </div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> i=<span class="number">0</span>;            <span class="comment">//i是常量，i的值不会被修改 </span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p1i=&amp;i;        <span class="comment">//指针p1i所指内容是常量，可以不初始化 </span></div><div class="line"><span class="keyword">int</span>  * <span class="keyword">const</span> p2i=&amp;ii;     <span class="comment">//指针p2i是常量，所指内容可修改 </span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p3i=&amp;i; <span class="comment">//指针p3i是常量，所指内容也是常量 </span></div><div class="line">p1i=&amp;ii;                  <span class="comment">//合法 </span></div><div class="line">*p2i=<span class="number">100</span>;                 <span class="comment">//合法</span></div></pre></td></tr></table></figure>
<h3 id="修饰函数参数"><a href="#修饰函数参数" class="headerlink" title="修饰函数参数"></a>修饰函数参数</h3><h4 id="const只能修饰输入参数："><a href="#const只能修饰输入参数：" class="headerlink" title="const只能修饰输入参数："></a>const只能修饰输入参数：</h4><p>如果参数作输出用，不论它是什么数据类型，也不论它采用“指针传递”还是“引用传递”，都不能加const修饰，否则该参数将失去输出功能。</p>
<p>如果输入参数采用“指针传递”，那么加const修饰可以防止意外地改动该指针，起到保护作用</p>
<p>例如StringCopy函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">StringCopy</span><span class="params">(<span class="keyword">char</span> *strDestination, <span class="keyword">const</span> <span class="keyword">char</span> *strSource)</span></span>;</div></pre></td></tr></table></figure>
<p>其中strSource是输入参数，strDestination是输出参数。给strSource加上const修饰后，如果函数体内的语句试图改动strSource的内容，编译器将指出错误。</p>
<h4 id="“值传递”无需const修饰"><a href="#“值传递”无需const修饰" class="headerlink" title="“值传递”无需const修饰"></a>“值传递”无需const修饰</h4><p>如果输入参数采用“值传递”，由于函数将<strong>自动产生临时变量</strong>用于复制该参数，该输入参数本来就无需保护，所以不要加const修饰。</p>
<p>例如不要将函数<code>voidFunc1(int x)</code> 写成<code>voidFunc1(const int x)</code>。同理不要将函数<code>voidFunc2(A a)</code> 写成<code>voidFunc2(const A a)</code>。其中A为用户自定义的数据类型。</p>
<h4 id="非内部类型输入参数，采取const引用传递"><a href="#非内部类型输入参数，采取const引用传递" class="headerlink" title="非内部类型输入参数，采取const引用传递"></a>非内部类型输入参数，采取const引用传递</h4><p>对于非内部数据类型的参数而言，像<code>voidFunc(A a)</code> 这样声明的函数注定效率比较底。因为函数体内将产生A类型的临时对象用于复制参数a，而临时对象的构造、复制、析构过程都将消耗时间。</p>
<p>为了<strong>提高效率</strong>，可以将函数声明改为voidFunc(A &amp;a)，因为“引用传递”仅借用一下参数的别名而已，不需要产生临时对象。但是函数voidFunc(A &amp;a) 存在一个缺点：</p>
<p>“引用传递”有可能改变参数a，这是我们不期望的。解决这个问题很容易，加const修饰即可，因此函数最终成为<code>voidFunc(const A &amp;a)</code>。</p>
<h4 id="内部类型输入参数，不必采取const引用传递"><a href="#内部类型输入参数，不必采取const引用传递" class="headerlink" title="内部类型输入参数，不必采取const引用传递"></a>内部类型输入参数，不必采取const引用传递</h4><p>以此类推，是否应将<code>voidFunc(int x)</code> 改写为<code>voidFunc(const int&amp;x)</code>，以便提高效率？完全没有必要，因为内部数据类型的参数不存在构造、析构的过程，而复制也非常快，“值传递”和“引用传递”的效率几乎相当。</p>
<p>因此，</p>
<p><strong>对于非内部数据类型的输入参数，应该将“值传递”的方式改为“const引用传递”，目的是提高效率。</strong>例如将<code>voidFunc(A a)</code> 改为<code>voidFunc(const A &amp;a)</code>。</p>
<p><strong>对于内部数据类型的输入参数，不要将“值传递”的方式改为“const引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性。</strong>例如<code>voidFunc(int x)</code> 不应该改为<code>voidFunc(const int &amp;x)</code>。</p>
<h3 id="修饰函数返回值"><a href="#修饰函数返回值" class="headerlink" title="修饰函数返回值"></a>修饰函数返回值</h3><h4 id="“指针传递”方式返回值"><a href="#“指针传递”方式返回值" class="headerlink" title="“指针传递”方式返回值"></a>“指针传递”方式返回值</h4><p>如果给以“指针传递”方式的函数返回值加const修饰，那么函数返回值（即指针）的内容不能被修改，该返回值只能被赋给加const修饰的同类型指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function">constchar *<span class="title">GetString</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line">如下语句将出现编译错误：</div><div class="line"><span class="keyword">char</span> *str = GetString();</div><div class="line">正确的用法是</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str = GetString();</div></pre></td></tr></table></figure>
<h4 id="“值传递”方式返回值"><a href="#“值传递”方式返回值" class="headerlink" title="“值传递”方式返回值"></a>“值传递”方式返回值</h4><p>如果函数返回值采用“值传递方式”，由于函数会把返回值复制到外部临时的存储单元中，加const修饰没有任何价值。</p>
<p>例如不要把函数<code>int GetInt(void)</code> 写成<code>const int GetInt(void)</code>。</p>
<p>同理不要把函数<code>A GetA(void)</code> 写成<code>const A GetA(void)</code>，其中A为用户自定义的数据类型。</p>
<h4 id="“引用传递”方式返回"><a href="#“引用传递”方式返回" class="headerlink" title="“引用传递”方式返回"></a>“引用传递”方式返回</h4><p>如果返回值不是内部数据类型，将函数<code>A GetA(void)</code> 改写为<code>const A &amp;GetA(void)</code>的确能提高效率。但此时千万千万要小心，一定要搞清楚函数究竟是想返回一个对象的“拷贝”还是仅返回“别名”就可以了，否则程序会出错。若返回对象的“拷贝”就应该采用“值传递”，仅返回“别名”可以用“引用传递”。</p>
<p>函数返回值采用“引用传递”的场合并不多，这种方式一般只出现在类的赋值函数中，目的是为了实现链式表达。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">classA &#123;</div><div class="line">	A &amp;operate = (<span class="keyword">const</span> A &amp;other); <span class="comment">// 赋值函数</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">int</span> main &#123;</div><div class="line">	A a, b, c; 		<span class="comment">// a, b, c 为A的对象</span></div><div class="line">	a = b = c; 		<span class="comment">// 正常的链式赋值</span></div><div class="line">	(a = b) = c;	<span class="comment">// 不正常的链式赋值，但合法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果将赋值函数的返回值加const修饰，即</p>
<pre><code>const A &amp;operate = (const A &amp;other);
</code></pre><p>那么该返回值的内容不允许被改动。上例中，语句<code>a = b = c</code> 仍然正确，但是语句<code>(a = b) = c</code> 则是非法的。</p>
<h3 id="修饰类的数据成员"><a href="#修饰类的数据成员" class="headerlink" title="修饰类的数据成员"></a>修饰类的数据成员</h3><p>不能在类声明中初始化const数据成员。以下用法是错误的，因为类的对象未被创建时，编译器不知道SIZE的值是什么。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> &#123;</span></div><div class="line">	<span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">100</span>;     <span class="comment">// 错误，企图在类声明中初始化const数据成员</span></div><div class="line">	<span class="keyword">int</span> <span class="built_in">array</span>[SIZE];          <span class="comment">// 错误，未知的SIZE</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>正确的使用const实现方法为：const数据成员的初始化只能在类构造函数的初始化表中进行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></div><div class="line">	A(<span class="keyword">int</span> size);      <span class="comment">// 构造函数</span></div><div class="line">	<span class="keyword">const</span> <span class="keyword">int</span> SIZE ; </div><div class="line">&#125;;</div><div class="line"></div><div class="line">A::A(<span class="keyword">int</span> size) : SIZE(size)    <span class="comment">// 构造函数的初始化表</span></div><div class="line">&#123;</div><div class="line">	...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// error 赋值的方式是不行的</span></div><div class="line">A::A(<span class="keyword">int</span> size)</div><div class="line">&#123;</div><div class="line">     SIZE=size;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> main（）&#123;</div><div class="line">    <span class="function">A  <span class="title">a</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">// 对象 a 的SIZE值为100</span></div><div class="line">    <span class="function">A  <span class="title">b</span><span class="params">(<span class="number">200</span>)</span></span>; <span class="comment">// 对象 b 的SIZE值为200</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>static和const也以同时修饰数据成员。</strong> 然而，它们不能同时修饰成员函数，这两点要注意区别。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Year</span> &#123;</span> </div><div class="line"><span class="keyword">private</span>:</div><div class="line">	<span class="keyword">int</span> y; </div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">const</span> Inity;</div><div class="line"><span class="keyword">public</span>: </div><div class="line">	Year() &#123;</div><div class="line">		y = Inity;</div><div class="line"> 	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">int</span> <span class="keyword">const</span> Year::Inity = <span class="number">1997</span>;	<span class="comment">//静态变量的赋值方法,注意必须放在类外定义</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;Year.Inity&lt;&lt;<span class="built_in">endl</span>;		<span class="comment">//注意调用方式，这里是用类名调用的。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="修饰类的成员函数"><a href="#修饰类的成员函数" class="headerlink" title="修饰类的成员函数"></a>修饰类的成员函数</h3><p><strong>任何不会修改数据成员的函数都应该声明为const类型。</strong>如果在编写const成员函数时，不慎修改了<strong>数据成员</strong>，或者调用了其它<strong>非const成员函数</strong>，编译器将指出错误，这无疑会提高程序的健壮性。</p>
<p>const放在函数末尾修饰const成员函数，因为const关键字是<strong>左结合</strong>。</p>
<p>以下程序中，类stack的成员函数GetCount仅用于计数，从逻辑上讲GetCount应当为const函数。编译器将指出GetCount函数中的错误。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> elem)</span></span>;</div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">GetCount</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span>; <span class="comment">// const 成员函数</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">	<span class="keyword">int</span> m_num;</div><div class="line">	<span class="keyword">int</span> m_data[<span class="number">100</span>];</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">int</span> Stack::GetCount(<span class="keyword">void</span>) <span class="keyword">const</span> &#123;</div><div class="line">	++ m_num; 	<span class="comment">// 编译错误，企图修改数据成员m_num</span></div><div class="line">	Pop();		<span class="comment">// 编译错误，企图调用非const函数</span></div><div class="line">	<span class="keyword">return</span> m_num;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果有个成员函数想修改对象中的某一个成员怎么办？这时我们可以使用<code>mutable</code>关键字修饰这个成员，<code>mutable</code>的意思也是易变的，容易改变的意思，被mutable关键字修饰的成员可以处于不断变化中，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> elem)</span></span>;</div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">GetCount</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span>; <span class="comment">// const 成员函数</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">	<span class="keyword">mutable</span> <span class="keyword">int</span> m_num;		  <span class="comment">// mutable 数据成员</span></div><div class="line">	<span class="keyword">int</span> m_data[<span class="number">100</span>];</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">int</span> Stack::GetCount(<span class="keyword">void</span>) <span class="keyword">const</span> &#123;</div><div class="line">	++ m_num; 	<span class="comment">// 编译通过，在const函数中修改mutable数据成员m_num</span></div><div class="line">	<span class="keyword">return</span> m_num;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注意： 不可以同时用const和static修饰成员函数。</strong></p>
<p>C++编译器在实现const的成员函数的时候为了确保该函数不能修改类的实例的状态，会在函数中添加一个隐式的参数const this*。但当一个成员为static的时候，该函数是没有this指针的。也就是说此时const的用法和static是冲突的。</p>
<p>我们也可以这样理解：两者的语意是矛盾的。static的作用是表示该函数只作用在类型的静态变量上，与类的实例没有关系；而const的作用是确保函数不能修改类的实例的状态，与类型的静态变量没有关系。因此不能同时用它们。</p>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>在局部变量之前加上关键字static，局部变量就被定义成为一个局部静态变量。</p>
<ol>
<li>内存中的位置：静态存储区</li>
<li>初始化：未经初始化的全局静态变量会被程序自动初始化为0（自动对象的值是任意的，除非他被显示初始化）</li>
<li>作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域随之结束。</li>
<li>生命周期：直到程序结束。</li>
</ol>
<p>注：当static用来修饰局部变量的时候，它就改变了局部变量的存储位置（从原来的栈中存放改为静态存储区）及其生命周期（局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问），但未改变其作用域。</p>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>在全局变量之前加上关键字static，全局变量就被定义成为一个全局静态变量。</p>
<ol>
<li>内存中的位置：静态存储区（静态存储区在整个程序运行期间都存在）</li>
<li>初始化：未经初始化的全局静态变量会被程序自动初始化为0（自动对象的值是任意的，除非他被显示初始化）</li>
<li>作用域：全局静态变量在声明他的文件之外是不可见的。准确地讲从定义之处开始到文件结尾。</li>
<li>生命周期：直到程序结束。</li>
</ol>
<p>注：static修饰全局变量，并未改变其存储位置及生命周期，而是改变了其作用域，使当前文件外的源文件无法访问该变量，好处如下：（1）不会被其他文件所访问，修改。（2）其他文件中可以使用相同名字的变量，不会发生冲突。对全局函数也是有隐藏作用。</p>
<h3 id="类中的成员变量"><a href="#类中的成员变量" class="headerlink" title="类中的成员变量"></a>类中的成员变量</h3><p>用static修饰类的数据成员实际使其成为类的全局变量，会被类的<strong>所有对象</strong>共享，包括<strong>派生类的对象</strong>。因此，static成员必须在类外进行初始化(初始化格式： <code>int base::var=10;</code>)，而不能在构造函数内进行初始化，不过也可以用const修饰static数据成员在类内初始化。但是定义必须在类的外部，见上文。在类的内部const static类型即使赋字面值常量也只能算是声明，定义必须在外部进行。</p>
<p><strong>不要试图在头文件中定义(初始化)静态数据成员。</strong>在大多数的情况下，这样做会引起重复定义这样的错误。即使加上<code>#ifndef #define #endif</code>或者<code>#pragma once</code>也不行。 </p>
<p>静态数据成员可以成为成员函数的可选参数，而普通数据成员则不可以。</p>
<p>静态数据成员的类型可以是所属类的类型，而普通数据成员则不可以。普通数据成员的只能声明为所属类类型的指针或引用。</p>
<h3 id="类中的成员函数"><a href="#类中的成员函数" class="headerlink" title="类中的成员函数"></a>类中的成员函数</h3><p>用static修饰成员函数，使这个类只存在这一份函数，所有对象共享该函数，不含this指针。</p>
<p>静态成员是可以独立访问的，也就是说，无须创建任何对象实例就可以访问。<code>base::func(5,3);</code>当static成员函数在类外定义时不需要加static修饰符。</p>
<p>在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员。因为静态成员函数不含this指针。 </p>
<h2 id="struct-union"><a href="#struct-union" class="headerlink" title="struct / union"></a>struct / union</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>结构体struct：把不同类型的数据组合成一个整体，自定义类型。</p>
<p>共同体union：使几个不同类型的变量共同占用一段内存</p>
<h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><p>struct和union都有内存对齐，结构体的内存布局依赖于CPU、操作系统、编译器及编译时的对齐选项。</p>
<blockquote>
<p>关于内存对齐，先让我们看四个重要的基本概念：</p>
<ol>
<li>数据类型自身的对齐值：对于char型数据，其自身对齐值为1，对于short型为2，对于int,float,double类型，其自身对齐值为4，单位字节。</li>
<li>结构体或者类的自身对齐值：其成员中自身对齐值最大的那个值。</li>
<li>指定对齐值：#pragma pack(n)，n=1,2,4,8,16改变系统的对齐系数</li>
<li>数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中小的那个值。</li>
</ol>
</blockquote>
<p>首先根据结构体内部成员的自身对齐值得到结构体的自身对齐值（<strong>内部成员最大的长度</strong>），如果没有修改系统设定的默认补齐长度4的话，取较小的进行内存补齐。</p>
<h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><p>结构体struct：不同之处，stuct里每个成员都有自己独立的地址。sizeof(struct)是内存对齐后所有成员长度的加和。</p>
<p>共同体union：当共同体中存入新的数据后，原有的成员就失去了作用，新的数据被写到union的地址中。sizeof(union)是最长的数据成员的长度。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>struct和union都是由多个不同的数据类型成员组成, 但在任何同一时刻, union中只存放了一个被选中的成员, 而struct的所有成员都存在。在struct中，各成员都占有自己的内存空间，它们是同时存在的。一个struct变量的总长度等于所有成员长度之和。在Union中，所有成员不能同时占用它的内存空间，它们不能同时存在。Union变量的长度等于最长的成员的长度。对于union的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于struct的不同成员赋值是互不影响的。</p>
<h2 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h2><p>inline用来向编译器请求声明为内联函数，编译器有权拒绝。</p>
<h3 id="与宏函数的对比"><a href="#与宏函数的对比" class="headerlink" title="与宏函数的对比"></a>与宏函数的对比</h3><ul>
<li>内联函数在运行时可调试，而宏定义不可以;</li>
<li>编译器会对内联函数的参数类型做安全检查或自动类型转换（同普通函数），而宏定义则不会；</li>
<li>内联函数可以访问类的成员变量，宏定义则不能；</li>
<li>在类中声明同时定义的成员函数，自动转化为内联函数</li>
<li>宏只是预定义的函数，在编译阶段不进行类型安全性检查，在编译的时候将对应函数用宏命令替换。对程序性能无影响。</li>
</ul>
<h3 id="不能声明为inline的函数"><a href="#不能声明为inline的函数" class="headerlink" title="不能声明为inline的函数"></a>不能声明为inline的函数</h3><ul>
<li>包含了<strong>递归</strong>、<strong>循环</strong>等结构的函数一般不会被内联。</li>
<li><strong>虚拟函数</strong>一般不会内联，但是如果编译器能在编译时确定具体的调用函数，那么仍然会就地展开该函数。</li>
<li>如果通过<strong>函数指针</strong>调用内联函数，那么该函数将不会内联而是通过call进行调用。</li>
<li><strong>构造和析构函数</strong>一般会生成大量代码，因此一般也不适合内联。</li>
<li>如果内联函数<strong>调用了其他函数</strong>也不会被内联。</li>
</ul>
<h2 id="typedef-using"><a href="#typedef-using" class="headerlink" title="typedef / using"></a>typedef / using</h2><p>二者功能都是定义新类型，using 为c++11新特性。下面语句功能一致：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> MyInt;</div><div class="line"></div><div class="line"><span class="keyword">using</span> MyInt = <span class="keyword">int</span>;</div></pre></td></tr></table></figure>
<h2 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h2><p>explicit禁止了隐式转换类型，用来修饰构造函数。原则上应该在所有的构造函数前加explicit关键字，当你有心利用隐式转换的时候再去解除explicit，这样可以大大减少错误的发生。如果一个构造函数 </p>
<p><code>Foo(int)</code> ;则下面的语句是合法的:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Foo f; </div><div class="line">f = <span class="number">12</span>; <span class="comment">// 发生了隐式转换，先调用Foo(int)用12构建了一个临时对象，然后调用赋值运算符复制到f中</span></div></pre></td></tr></table></figure>
<p>如果给构造函数加了explicit,即 <code>explicit Foo(int)</code>；就只能进行显示转换，无法进行隐式转换了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">f = <span class="number">12</span>; 		<span class="comment">// 非法，隐式转换</span></div><div class="line">f = Foo(<span class="number">12</span>); 	<span class="comment">// 合法，显示转换</span></div><div class="line">f = (Foo) <span class="number">12</span>;	<span class="comment">// 合法，显示转换，C风格</span></div></pre></td></tr></table></figure>
<h2 id="指针-引用"><a href="#指针-引用" class="headerlink" title="指针 / 引用"></a>指针 / 引用</h2><p>本质上的区别是，指针是一个新的变量，只是这个变量存储的是另一个变量的地址，我们通过访问这个地址来修改变量。</p>
<p>而引用只是一个别名，还是变量本身。对引用进行的任何操作就是对变量本身进行操作，因此以达到修改变量的目的。</p>
<p>区别如下：</p>
<ol>
<li><p>指针：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。如：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a=<span class="number">1</span>; <span class="keyword">int</span> *p=&amp;a;</div><div class="line"><span class="keyword">int</span> a=<span class="number">1</span>; <span class="keyword">int</span> &amp;b=a;</div></pre></td></tr></table></figure>
<p> 上面定义了一个整形变量和一个指针变量p，该指针变量指向a的存储单元，即p的值是a存储单元的地址。</p>
<p> 而下面2句定义了一个整形变量a和这个整形a的引用b，事实上a和b是同一个东西，在内存占有同一个存储单元。</p>
</li>
<li><p>可以有const指针，但是没有const引用（一般说的const引用其实是指向const对象的引用）；</p>
</li>
<li>指针可以有多级，但是引用只能是一级（int **p；合法 而 int &amp;&amp;a是不合法的）</li>
<li>指针的值可以为空，但是引用的值不能为NULL，并且<strong>引用在定义的时候必须初始化</strong>；</li>
<li>指针的值在初始化后可以改变，即指向其它的存储单元，而<strong>引用在进行初始化后就不会再改变</strong>了。</li>
<li>“sizeof引用”得到的是所指向的变量(对象)的大小，而”sizeof指针”得到的是指针本身的大小；</li>
<li>指针和引用的自增(++)运算意义不一样。</li>
<li>指针传参的时候，还是值传递，试图修改传进来的指针的值是不可以的。只能修改地址所保存变量的值。引用传参的时候，传进来的就是变量本身，因此可以被修改。</li>
</ol>
<p><strong>注意：const引用只是表明，保证不会通过此引用间接的改变被引用的对象！</strong> 详见:<a href="https://www.cnblogs.com/chio/archive/2007/07/18/822362.html" target="_blank" rel="noopener">C++引用与const引用</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/25/c_sharp_delegate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Oizys">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/o1zys">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Oizys's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/25/c_sharp_delegate/" itemprop="url">C# 中的委托和事件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-25T19:06:12+08:00">
                2017-12-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/csharp/" itemprop="url" rel="index">
                    <span itemprop="name">csharp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/12/25/c_sharp_delegate/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/12/25/c_sharp_delegate/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>转自：<a href="http://www.tracefact.net/CSharp-Programming/Delegates-and-Events-in-CSharp.aspx" target="_blank" rel="noopener">http://www.tracefact.net/CSharp-Programming/Delegates-and-Events-in-CSharp.aspx</a><br>作者：张子阳</p>
</blockquote>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><strong>委托(Delegates)</strong>和 <strong>事件(Events)</strong>在 .Net Framework中的应用非常广泛，然而，较好地理解委托和事件对很多接触C#时间不长的人来说并不容易。它们就像是一道槛儿，过了这个槛的人，觉得真是太容易了，而没有过去的人每次见到委托和事件就觉得心里别（biè）得慌，混身不自在。</p>
<p>本文中，我将通过两个范例由浅入深地讲述什么是委托、为什么要使用委托、事件的由来、.Net Framework中的委托和事件、委托和事件对Observer设计模式的意义，对它们的中间代码也做了讨论。</p>
<h1 id="将方法作为方法的参数"><a href="#将方法作为方法的参数" class="headerlink" title="将方法作为方法的参数"></a>将方法作为方法的参数</h1><p>我们先不管这个标题如何的绕口，也不管委托究竟是个什么东西，来看下面这两个最简单的方法，它们不过是在屏幕上输出一句问候的话语：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">GreetPeople</span>(<span class="params"><span class="keyword">string</span> name</span>) </span>&#123;</div><div class="line">    <span class="comment">// 做某些额外的事情，比如初始化之类，此处略</span></div><div class="line">    EnglishGreeting(name);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">EnglishGreeting</span>(<span class="params"><span class="keyword">string</span> name</span>) </span>&#123;</div><div class="line">    Console.WriteLine(<span class="string">"Morning, "</span> + name);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>暂且不管这两个方法有没有什么实际意义。GreetPeople用于向某人问好，当我们传递代表某人姓名的name参数，比如说“Jimmy”，进去的时候，在这个方法中，将调用EnglishGreeting方法，再次传递name参数，EnglishGreeting则用于向屏幕输出 “Morning, Jimmy”。</p>
<p>现在假设这个程序需要进行全球化，哎呀，不好了，我是中国人，我不明白“Morning”是什么意思，怎么办呢？好吧，我们再加个中文版的问候方法：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChineseGreeting</span>(<span class="params"><span class="keyword">string</span> name</span>)</span>&#123;</div><div class="line">    Console.WriteLine(<span class="string">"早上好, "</span> + name);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这时候，GreetPeople也需要改一改了，不然如何判断到底用哪个版本的Greeting问候方法合适呢？在进行这个之前，我们最好再定义一个枚举作为判断的依据：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Language&#123;</div><div class="line">    English, Chinese</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GreetPeople</span>(<span class="params"><span class="keyword">string</span> name, Language lang</span>)</span>&#123;</div><div class="line">    <span class="comment">//做某些额外的事情，比如初始化之类，此处略</span></div><div class="line">    swith(lang)&#123;</div><div class="line">        <span class="keyword">case</span> Language.English:</div><div class="line">            EnglishGreeting(name);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> Language.Chinese:</div><div class="line">            ChineseGreeting(name);</div><div class="line">        reak;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>OK，尽管这样解决了问题，但我不说大家也很容易想到，这个解决方案的可扩展性很差，如果日后我们需要再添加韩文版、日文版，就不得不反复修改枚举和GreetPeople()方法，以适应新的需求。<br>在考虑新的解决方案之前，我们先看看 GreetPeople的方法签名：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GreetPeople</span>(<span class="params"><span class="keyword">string</span> name, Language lang</span>)</span></div></pre></td></tr></table></figure></p>
<p>我们仅看 string name，在这里，string 是参数类型，name 是参数变量，当我们赋给name字符串“jimmy”时，它就代表“jimmy”这个值；当我们赋给它“张子阳”时，它又代表着“张子阳”这个值。然后，我们可以在方法体内对这个name进行其他操作。哎，这简直是废话么，刚学程序就知道了。</p>
<p>如果你再仔细想想，假如GreetPeople()方法可以接受一个参数变量，这个变量可以代表另一个方法，当我们给这个变量赋值 EnglishGreeting的时候，它代表着 EnglsihGreeting() 这个方法；当我们给它赋值ChineseGreeting 的时候，它又代表着ChineseGreeting()方法。</p>
<p>我们将这个参数变量命名为 MakeGreeting，那么不是可以如同给name赋值时一样，在调用 GreetPeople()方法的时候，给这个MakeGreeting 参数也赋上值么(ChineseGreeting或者EnglsihGreeting等)？</p>
<p>然后，我们在方法体内，也可以像使用别的参数一样使用MakeGreeting。但是，由于MakeGreeting代表着一个方法，它的使用方式应该和它被赋的方法(比如ChineseGreeting)是一样的，比如：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MakeGreeting(name);</div></pre></td></tr></table></figure></p>
<p>好了，有了思路了，我们现在就来改改GreetPeople()方法，那么它应该是这个样子了：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GreetPeople</span>(<span class="params"><span class="keyword">string</span> name, xxx MakeGreeting</span>)</span>&#123;</div><div class="line">    MakeGreeting(name);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意到 xxx ，这个位置通常放置的应该是参数的类型，但到目前为止，我们仅仅是想到应该有个可以代表方法的参数，并按这个思路去改写GreetPeople方法，现在就出现了一个大问题：这个代表着方法的MakeGreeting参数应该是什么类型的？</p>
<blockquote>
<p>NOTE：这里已不再需要枚举了，因为在给MakeGreeting赋值的时候动态地决定使用哪个方法，是ChineseGreeting还是 EnglishGreeting，而在这个两个方法内部，已经对使用“morning”还是“早上好”作了区分。</p>
</blockquote>
<p>聪明的你应该已经想到了，现在是委托该出场的时候了，但讲述委托之前，我们再看看MakeGreeting参数所能代表的 ChineseGreeting()和EnglishGreeting()方法的签名：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">EnglishGreeting</span>(<span class="params"><span class="keyword">string</span> name</span>)</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChineseGreeting</span>(<span class="params"><span class="keyword">string</span> name</span>)</div></pre></td></tr></table></figure></p>
<p>如同name可以接受String类型的“true”和“1”，但不能接受bool类型的true和int类型的1一样。MakeGreeting的 参数类型定义 应该能够确定 MakeGreeting可以代表的方法种类，再进一步讲，就是MakeGreeting可以代表的方法 的 参数类型和返回类型。</p>
<p>于是，委托出现了：它定义了MakeGreeting参数所能代表的方法的种类，也就是MakeGreeting参数的类型。</p>
<blockquote>
<p>NOTE：如果上面这句话比较绕口，我把它翻译成这样：string 定义了name参数所能代表的值的种类，也就是name参数的类型。</p>
</blockquote>
<p>本例中委托的定义：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">GreetingDelegate</span>(<span class="params"><span class="keyword">string</span> name</span>)</span>;</div></pre></td></tr></table></figure></p>
<p>可以与上面EnglishGreeting()方法的签名对比一下，除了加入了delegate关键字以外，其余的是不是完全一样？</p>
<p>现在，让我们再次改动GreetPeople()方法，如下所示：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GreetPeople</span>(<span class="params"><span class="keyword">string</span> name, GreetingDelegate MakeGreeting</span>)</span>&#123;</div><div class="line">    MakeGreeting(name);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如你所见，委托GreetingDelegate出现的位置与 string相同，string是一个类型，那么GreetingDelegate应该也是一个类型，或者叫类(Class)。但是委托的声明方式和类却完全不同，这是怎么一回事？实际上，委托在编译的时候确实会编译成类。因为Delegate是一个类，所以在任何可以声明类的地方都可以声明委托。更多的内容将在下面讲述，现在，请看看这个范例的完整代码：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> System;</div><div class="line"><span class="keyword">using</span> System.Collections.Generic;</div><div class="line"><span class="keyword">using</span> System.Text;</div><div class="line"></div><div class="line"><span class="keyword">namespace</span> <span class="title">Delegate</span> &#123;</div><div class="line">     <span class="comment">//定义委托，它定义了可以代表的方法的类型</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">GreetingDelegate</span>(<span class="params"><span class="keyword">string</span> name</span>)</span>;</div><div class="line">        <span class="keyword">class</span> <span class="title">Program</span> &#123;</div><div class="line"></div><div class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">EnglishGreeting</span>(<span class="params"><span class="keyword">string</span> name</span>) </span>&#123;</div><div class="line">                Console.WriteLine(<span class="string">"Morning, "</span> + name);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ChineseGreeting</span>(<span class="params"><span class="keyword">string</span> name</span>) </span>&#123;</div><div class="line">                Console.WriteLine(<span class="string">"早上好, "</span> + name);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//注意此方法，它接受一个GreetingDelegate类型的方法作为参数</span></div><div class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GreetPeople</span>(<span class="params"><span class="keyword">string</span> name, GreetingDelegate MakeGreeting</span>) </span>&#123;</div><div class="line">                MakeGreeting(name);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>) </span>&#123;</div><div class="line">                GreetPeople(<span class="string">"Jimmy Zhang"</span>, EnglishGreeting);</div><div class="line">                GreetPeople(<span class="string">"张子阳"</span>, ChineseGreeting);</div><div class="line">                Console.ReadKey();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>输出如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Morning, Jimmy Zhang</div><div class="line">早上好, 张子阳</div></pre></td></tr></table></figure></p>
<p>我们现在对委托做一个总结：<br>委托是一个类，它定义了方法的类型，使得可以将方法当作另一个方法的参数来进行传递，这种将方法动态地赋给参数的做法，可以避免在程序中大量使用If-Else(Switch)语句，同时使得程序具有更好的可扩展性。</p>
<h1 id="将方法绑定到委托"><a href="#将方法绑定到委托" class="headerlink" title="将方法绑定到委托"></a>将方法绑定到委托</h1><p>看到这里，是不是有那么点如梦初醒的感觉？于是，你是不是在想：在上面的例子中，我不一定要直接在GreetPeople()方法中给 name参数赋值，我可以像这样使用变量：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>) </span>&#123;</div><div class="line">    <span class="keyword">string</span> name1, name2;</div><div class="line">    name1 = <span class="string">"Jimmy Zhang"</span>;</div><div class="line">    name2 = <span class="string">"张子阳"</span>; </div><div class="line"></div><div class="line">     GreetPeople(name1, EnglishGreeting);</div><div class="line">     GreetPeople(name2, ChineseGreeting);</div><div class="line">    Console.ReadKey();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而既然委托GreetingDelegate 和 类型 string 的地位一样，都是定义了一种参数类型，那么，我是不是也可以这么使用委托？<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>) </span>&#123;</div><div class="line">    GreetingDelegate delegate1, delegate2;</div><div class="line">    delegate1 = EnglishGreeting;</div><div class="line">    delegate2 = ChineseGreeting;</div><div class="line"></div><div class="line">    GreetPeople(<span class="string">"Jimmy Zhang"</span>, delegate1);</div><div class="line">        GreetPeople(<span class="string">"张子阳"</span>, delegate2);</div><div class="line">        Console.ReadKey();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如你所料，这样是没有问题的，程序一如预料的那样输出。这里，我想说的是委托不同于string的一个特性：可以将多个方法赋给同一个委托，或者叫将多个方法绑定到同一个委托，当调用这个委托的时候，将依次调用其所绑定的方法。在这个例子中，语法如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>) </span>&#123;</div><div class="line">    GreetingDelegate delegate1;</div><div class="line">    delegate1 = EnglishGreeting; <span class="comment">// 先给委托类型的变量赋值</span></div><div class="line">    delegate1 += ChineseGreeting;   <span class="comment">// 给此委托变量再绑定一个方法</span></div><div class="line"></div><div class="line">     <span class="comment">// 将先后调用 EnglishGreeting 与 ChineseGreeting 方法</span></div><div class="line">    GreetPeople(<span class="string">"Jimmy Zhang"</span>, delegate1);  </div><div class="line">    Console.ReadKey();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Morning, Jimmy Zhang</div><div class="line">早上好, Jimmy Zhang</div></pre></td></tr></table></figure></p>
<p>实际上，我们可以也可以绕过GreetPeople方法，通过委托来直接调用EnglishGreeting和ChineseGreeting：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>) </span>&#123;</div><div class="line">    GreetingDelegate delegate1;</div><div class="line">    delegate1 = EnglishGreeting; <span class="comment">// 先给委托类型的变量赋值</span></div><div class="line">    delegate1 += ChineseGreeting;   <span class="comment">// 给此委托变量再绑定一个方法</span></div><div class="line"></div><div class="line">    <span class="comment">// 将先后调用 EnglishGreeting 与 ChineseGreeting 方法</span></div><div class="line">    delegate1 (<span class="string">"Jimmy Zhang"</span>);</div><div class="line">    Console.ReadKey();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>NOTE：这在本例中是没有问题的，但回头看下上面GreetPeople()的定义，在它之中可以做一些对于EnglshihGreeting和ChineseGreeting来说都需要进行的工作，为了简便我做了省略。<br>注意这里，第一次用的“=”，是赋值的语法；第二次，用的是“+=”，是绑定的语法。如果第一次就使用“+=”，将出现“使用了未赋值的局部变量”的编译错误。</p>
</blockquote>
<p>我们也可以使用下面的代码来这样简化这一过程：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">GreetingDelegate delegate1 = <span class="keyword">new</span> GreetingDelegate(EnglishGreeting);</div><div class="line">delegate1 += ChineseGreeting;   <span class="comment">// 给此委托变量再绑定一个方法</span></div></pre></td></tr></table></figure></p>
<p>看到这里，应该注意到，这段代码第一条语句与实例化一个类是何其的相似，你不禁想到：上面第一次绑定委托时不可以使用“+=”的编译错误，或许可以用这样的方法来避免：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">GreetingDelegate delegate1 = <span class="keyword">new</span> GreetingDelegate();</div><div class="line">delegate1 += EnglishGreeting;   <span class="comment">// 这次用的是 “+=”，绑定语法。</span></div><div class="line">delegate1 += ChineseGreeting;   <span class="comment">// 给此委托变量再绑定一个方法</span></div></pre></td></tr></table></figure></p>
<p>但实际上，这样会出现编译错误： “GreetingDelegate”方法没有采用“0”个参数的重载。尽管这样的结果让我们觉得有点沮丧，但是编译的提示：“没有0个参数的重载”再次让我们联想到了类的构造函数。我知道你一定按捺不住想探个究竟，但再此之前，我们需要先把基础知识和应用介绍完。</p>
<p>既然给委托可以绑定一个方法，那么也应该有办法取消对方法的绑定，很容易想到，这个语法是“-=”：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>) </span>&#123;</div><div class="line">    GreetingDelegate delegate1 = <span class="keyword">new</span> GreetingDelegate(EnglishGreeting);</div><div class="line">    delegate1 += ChineseGreeting;   <span class="comment">// 给此委托变量再绑定一个方法</span></div><div class="line"></div><div class="line">    <span class="comment">// 将先后调用 EnglishGreeting 与 ChineseGreeting 方法</span></div><div class="line">    GreetPeople(<span class="string">"Jimmy Zhang"</span>, delegate1);  </div><div class="line">    Console.WriteLine();</div><div class="line"></div><div class="line">    delegate1 -= EnglishGreeting; <span class="comment">//取消对EnglishGreeting方法的绑定</span></div><div class="line">    <span class="comment">// 将仅调用 ChineseGreeting </span></div><div class="line">    GreetPeople(<span class="string">"张子阳"</span>, delegate1); </div><div class="line">    Console.ReadKey();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Morning, Jimmy Zhang</div><div class="line">早上好, Jimmy Zhang</div><div class="line">早上好, 张子阳</div></pre></td></tr></table></figure></p>
<p>让我们再次对委托作个总结：<br>使用委托可以将多个方法绑定到同一个委托变量，当调用此变量时(这里用“调用”这个词，是因为此变量代表一个方法)，可以依次调用所有绑定的方法。</p>
<h1 id="事件的由来"><a href="#事件的由来" class="headerlink" title="事件的由来"></a>事件的由来</h1><p>我们继续思考上面的程序：上面的三个方法都定义在Programe类中，这样做是为了理解的方便，实际应用中，通常都是 GreetPeople 在一个类中，ChineseGreeting和 EnglishGreeting 在另外的类中。现在你已经对委托有了初步了解，是时候对上面的例子做个改进了。假设我们将GreetingPeople()放在一个叫GreetingManager的类中，那么新程序应该是这个样子的：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> <span class="title">Delegate</span> &#123;</div><div class="line">    <span class="comment">//定义委托，它定义了可以代表的方法的类型</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">GreetingDelegate</span>(<span class="params"><span class="keyword">string</span> name</span>)</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//新建的GreetingManager类</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GreetingManager</span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GreetPeople</span>(<span class="params"><span class="keyword">string</span> name, GreetingDelegate MakeGreeting</span>) </span>&#123;</div><div class="line">            MakeGreeting(name);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">class</span> <span class="title">Program</span> &#123;</div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">EnglishGreeting</span>(<span class="params"><span class="keyword">string</span> name</span>) </span>&#123;</div><div class="line">            Console.WriteLine(<span class="string">"Morning, "</span> + name);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ChineseGreeting</span>(<span class="params"><span class="keyword">string</span> name</span>) </span>&#123;</div><div class="line">            Console.WriteLine(<span class="string">"早上好, "</span> + name);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>) </span>&#123;</div><div class="line">            <span class="comment">// ... ...</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个时候，如果要实现前面演示的输出效果，Main方法我想应该是这样的：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>) </span>&#123;</div><div class="line">    GreetingManager gm = <span class="keyword">new</span>  GreetingManager();</div><div class="line">    gm.GreetPeople(<span class="string">"Jimmy Zhang"</span>, EnglishGreeting);</div><div class="line">    gm.GreetPeople(<span class="string">"张子阳"</span>, ChineseGreeting);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们运行这段代码，嗯，没有任何问题。程序一如预料地那样输出了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Morning, Jimmy Zhang</div><div class="line"></div><div class="line">早上好, 张子阳</div></pre></td></tr></table></figure></p>
<p>现在，假设我们需要使用上一节学到的知识，将多个方法绑定到同一个委托变量，该如何做呢？让我们再次改写代码：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>) </span>&#123;</div><div class="line">    GreetingManager gm = <span class="keyword">new</span>  GreetingManager();</div><div class="line">    GreetingDelegate delegate1;</div><div class="line">    delegate1 = EnglishGreeting;</div><div class="line">    delegate1 += ChineseGreeting;</div><div class="line"></div><div class="line">    gm.GreetPeople(<span class="string">"Jimmy Zhang"</span>, delegate1);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Morning, Jimmy Zhang</div><div class="line">早上好, Jimmy Zhang</div></pre></td></tr></table></figure></p>
<p>到了这里，我们不禁想到：面向对象设计，讲究的是对象的封装，既然可以声明委托类型的变量(在上例中是delegate1)，我们何不将这个变量封装到 GreetManager类中？在这个类的客户端中使用不是更方便么？于是，我们改写GreetManager类，像这样：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GreetingManager</span>&#123;</div><div class="line">    <span class="comment">//在GreetingManager类的内部声明delegate1变量</span></div><div class="line">    <span class="keyword">public</span> GreetingDelegate delegate1;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GreetPeople</span>(<span class="params"><span class="keyword">string</span> name, GreetingDelegate MakeGreeting</span>) </span>&#123;</div><div class="line">       MakeGreeting(name);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在，我们可以这样使用这个委托变量：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>) </span>&#123;</div><div class="line">    GreetingManager gm = <span class="keyword">new</span>  GreetingManager();</div><div class="line">    gm.delegate1 = EnglishGreeting;</div><div class="line">    gm.delegate1 += ChineseGreeting;</div><div class="line"></div><div class="line">    gm.GreetPeople(<span class="string">"Jimmy Zhang"</span>, gm.delegate1);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Morning, Jimmy Zhang</div><div class="line">早上好, Jimmy Zhang</div></pre></td></tr></table></figure></p>
<p>尽管这样做没有任何问题，但我们发现这条语句很奇怪。在调用gm.GreetPeople方法的时候，再次传递了gm的delegate1字段：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gm.GreetPeople(<span class="string">"Jimmy Zhang"</span>, gm.delegate1);</div></pre></td></tr></table></figure></p>
<p>既然如此，我们何不修改 GreetingManager 类成这样：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GreetingManager</span>&#123;</div><div class="line">    <span class="comment">//在GreetingManager类的内部声明delegate1变量</span></div><div class="line">    <span class="keyword">public</span> GreetingDelegate delegate1;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GreetPeople</span>(<span class="params"><span class="keyword">string</span> name</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span>(delegate1!=<span class="literal">null</span>)&#123;     <span class="comment">//如果有方法注册委托变量</span></div><div class="line">            delegate1(name);      <span class="comment">//通过委托调用方法</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">`</div></pre></td></tr></table></figure></p>
<p>在客户端，调用看上去更简洁一些：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>) </span>&#123;</div><div class="line">    GreetingManager gm = <span class="keyword">new</span>  GreetingManager();</div><div class="line">    gm.delegate1 = EnglishGreeting;</div><div class="line">    gm.delegate1 += ChineseGreeting;</div><div class="line"></div><div class="line">    gm.GreetPeople(<span class="string">"Jimmy Zhang"</span>);      <span class="comment">//注意，这次不需要再传递 delegate1变量</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出为：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Morning, Jimmy Zhang</div><div class="line">早上好, Jimmy Zhang</div></pre></td></tr></table></figure></p>
<p>尽管这样达到了我们要的效果，但是还是存在着问题：</p>
<p>在这里，delegate1和我们平时用的string类型的变量没有什么分别，而我们知道，并不是所有的字段都应该声明成public，合适的做法是应该public的时候public，应该private的时候private。<br>我们先看看如果把 delegate1 声明为 private会怎样？</p>
<p>结果就是：这简直就是在搞笑。因为声明委托的目的就是为了把它暴露在类的客户端进行方法的注册，你把它声明为private了，客户端对它根本就不可见，那它还有什么用？</p>
<p>再看看把delegate1 声明为 public 会怎样？结果就是：在客户端可以对它进行随意的赋值等操作，严重破坏对象的封装性。</p>
<p>最后，第一个方法注册用“=”，是赋值语法，因为要进行实例化，第二个方法注册则用的是“+=”。但是，不管是赋值还是注册，都是将方法绑定到委托上，除了调用时先后顺序不同，再没有任何的分别，这样不是让人觉得很别扭么？</p>
<p>现在我们想想，如果delegate1不是一个委托类型，而是一个string类型，你会怎么做？答案是使用属性对字段进行封装。</p>
<p>于是，Event出场了，它封装了委托类型的变量，使得：在类的内部，不管你声明它是public还是protected，它总是private的。在类的外部，注册“+=”和注销“-=”的访问限定符与你在声明事件时使用的访问符相同。</p>
<p>我们改写GreetingManager类，它变成了这个样子：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GreetingManager</span>&#123;</div><div class="line">    <span class="comment">//这一次我们在这里声明一个事件</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">event</span> GreetingDelegate MakeGreet;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GreetPeople</span>(<span class="params"><span class="keyword">string</span> name</span>) </span>&#123;</div><div class="line">        MakeGreet(name);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>很容易注意到：MakeGreet 事件的声明与之前委托变量delegate1的声明唯一的区别是多了一个event关键字。看到这里，在结合上面的讲解，你应该明白到：事件其实没什么不好理解的，声明一个事件不过类似于声明一个进行了封装的委托类型的变量而已。</p>
<p>为了证明上面的推论，如果我们像下面这样改写Main方法：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>) </span>&#123;</div><div class="line">    GreetingManager gm = <span class="keyword">new</span>  GreetingManager();</div><div class="line">    gm.MakeGreet = EnglishGreeting;         <span class="comment">// 编译错误1</span></div><div class="line">    gm.MakeGreet += ChineseGreeting;</div><div class="line"></div><div class="line">    gm.GreetPeople(<span class="string">"Jimmy Zhang"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>会得到编译错误：事件“Delegate.GreetingManager.MakeGreet”只能出现在 += 或 -= 的左边(从类型“Delegate.GreetingManager”中使用时除外)。</p>
<h1 id="事件和委托的编译代码"><a href="#事件和委托的编译代码" class="headerlink" title="事件和委托的编译代码"></a>事件和委托的编译代码</h1><p>这时候，我们注释掉编译错误的行，然后重新进行编译，再借助Reflactor来对 event的声明语句做一探究，看看为什么会发生这样的错误：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">event</span> GreetingDelegate MakeGreet;</div></pre></td></tr></table></figure></p>
<p>可以看到，实际上尽管我们在GreetingManager里将 MakeGreet 声明为public，但是，实际上MakeGreet会被编译成 私有字段，难怪会发生上面的编译错误了，因为它根本就不允许在GreetingManager类的外面以赋值的方式访问，从而验证了我们上面所做的推论。</p>
<p>我们再进一步看下MakeGreet所产生的代码：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> GreetingDelegate MakeGreet; <span class="comment">//对事件的声明 实际是 声明一个私有的委托变量</span></div><div class="line"> </div><div class="line">[<span class="meta">MethodImpl(MethodImplOptions.Synchronized)</span>]</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add_MakeGreet</span>(<span class="params">GreetingDelegate <span class="keyword">value</span></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.MakeGreet = (GreetingDelegate) Delegate.Combine(<span class="keyword">this</span>.MakeGreet, <span class="keyword">value</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">[<span class="meta">MethodImpl(MethodImplOptions.Synchronized)</span>]</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove_MakeGreet</span>(<span class="params">GreetingDelegate <span class="keyword">value</span></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.MakeGreet = (GreetingDelegate) Delegate.Remove(<span class="keyword">this</span>.MakeGreet, <span class="keyword">value</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在已经很明确了：MakeGreet事件确实是一个GreetingDelegate类型的委托，只不过不管是不是声明为public，它总是被声明为private。另外，它还有两个方法，分别是add_MakeGreet和remove_MakeGreet，这两个方法分别用于注册委托类型的方法和取消注册。实际上也就是： “+= ”对应 add_MakeGreet，“-=”对应remove_MakeGreet。而这两个方法的访问限制取决于声明事件时的访问限制符。</p>
<p>在add_MakeGreet()方法内部，实际上调用了System.Delegate的Combine()静态方法，这个方法用于将当前的变量添加到委托链表中。我们前面提到过两次，说委托实际上是一个类，在我们定义委托的时候：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">GreetingDelegate</span>(<span class="params"><span class="keyword">string</span> name</span>)</span>;</div></pre></td></tr></table></figure></p>
<p>当编译器遇到这段代码的时候，会生成下面这样一个完整的类：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public sealed class GreetingDelegate:System.MulticastDelegate&#123;</div><div class="line">    public GreetingDelegate(object @object, IntPtr method);</div><div class="line">    public virtual IAsyncResult BeginInvoke(string name, AsyncCallback callback, object @object);</div><div class="line">    public virtual void EndInvoke(IAsyncResult result);</div><div class="line">    public virtual void Invoke(string name);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>关于这个类的更深入内容，可以参阅《CLR Via C#》等相关书籍，这里就不再讨论了。</p>
<h1 id="委托、事件与Observer设计模式"><a href="#委托、事件与Observer设计模式" class="headerlink" title="委托、事件与Observer设计模式"></a>委托、事件与Observer设计模式</h1><h2 id="范例说明"><a href="#范例说明" class="headerlink" title="范例说明"></a>范例说明</h2><p>上面的例子已不足以再进行下面的讲解了，我们来看一个新的范例，因为之前已经介绍了很多的内容，所以本节的进度会稍微快一些：</p>
<p>假设我们有个高档的热水器，我们给它通上电，当水温超过95度的时候：1、扬声器会开始发出语音，告诉你水的温度；2、液晶屏也会改变水温的显示，来提示水已经快烧开了。</p>
<p>现在我们需要写个程序来模拟这个烧水的过程，我们将定义一个类来代表热水器，我们管它叫：Heater，它有代表水温的字段，叫做temperature；当然，还有必不可少的给水加热方法BoilWater()，一个发出语音警报的方法MakeAlert()，一个显示水温的方法，ShowMsg()。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> <span class="title">Delegate</span> &#123;</div><div class="line"><span class="keyword">class</span> <span class="title">Heater</span> &#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> temperature; <span class="comment">// 水温</span></div><div class="line">    <span class="comment">// 烧水</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BoilWater</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</div><div class="line">           temperature = i;</div><div class="line"></div><div class="line">           <span class="keyword">if</span> (temperature &gt; <span class="number">95</span>) &#123;</div><div class="line">               MakeAlert(temperature);</div><div class="line">               ShowMsg(temperature);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 发出语音警报</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MakeAlert</span>(<span class="params"><span class="keyword">int</span> param</span>) </span>&#123;</div><div class="line">       Console.WriteLine(<span class="string">"Alarm：嘀嘀嘀，水已经 &#123;0&#125; 度了："</span> , param);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 显示水温</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ShowMsg</span>(<span class="params"><span class="keyword">int</span> param</span>) </span>&#123;</div><div class="line">       Console.WriteLine(<span class="string">"Display：水快开了，当前温度：&#123;0&#125;度。"</span> , param);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>) </span>&#123;</div><div class="line">       Heater ht = <span class="keyword">new</span> Heater();</div><div class="line">       ht.BoilWater();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Observer设计模式简介"><a href="#Observer设计模式简介" class="headerlink" title="Observer设计模式简介"></a>Observer设计模式简介</h2><p>上面的例子显然能完成我们之前描述的工作，但是却并不够好。现在假设热水器由三部分组成：热水器、警报器、显示器，它们来自于不同厂商并进行了组装。那么，应该是热水器仅仅负责烧水，它不能发出警报也不能显示水温；在水烧开时由警报器发出警报、显示器显示提示和水温。</p>
<p>这时候，上面的例子就应该变成这个样子：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 热水器</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Heater</span> &#123; </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> temperature;</div><div class="line">        </div><div class="line">    <span class="comment">// 烧水</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">BoilWater</span>(<span class="params"></span>) </span>&#123;</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</div><div class="line">           temperature = i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 警报器</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Alarm</span>&#123;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MakeAlert</span>(<span class="params"><span class="keyword">int</span> param</span>) </span>&#123;</div><div class="line">       Console.WriteLine(<span class="string">"Alarm：嘀嘀嘀，水已经 &#123;0&#125; 度了："</span> , param);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 显示器</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Display</span>&#123;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ShowMsg</span>(<span class="params"><span class="keyword">int</span> param</span>) </span>&#123;</div><div class="line">       Console.WriteLine(<span class="string">"Display：水已烧开，当前温度：&#123;0&#125;度。"</span> , param);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里就出现了一个问题：如何在水烧开的时候通知报警器和显示器？在继续进行之前，我们先了解一下Observer设计模式，Observer设计模式中主要包括如下两类对象：</p>
<ol>
<li>Subject：监视对象，它往往包含着其他对象所感兴趣的内容。在本范例中，热水器就是一个监视对象，它包含的其他对象所感兴趣的内容，就是temprature字段，当这个字段的值快到100时，会不断把数据发给监视它的对象。</li>
<li>Observer：监视者，它监视Subject，当Subject中的某件事发生的时候，会告知Observer，而Observer则会采取相应的行动。在本范例中，Observer有警报器和显示器，它们采取的行动分别是发出警报和显示水温。</li>
</ol>
<p>在本例中，事情发生的顺序应该是这样的：</p>
<ol>
<li>警报器和显示器告诉热水器，它对它的温度比较感兴趣(注册)。</li>
<li>热水器知道后保留对警报器和显示器的引用。</li>
<li>热水器进行烧水这一动作，当水温超过95度时，通过对警报器和显示器的引用，自动调用警报器的MakeAlert()方法、显示器的ShowMsg()方法。</li>
</ol>
<p>类似这样的例子是很多的，GOF对它进行了抽象，称为Observer设计模式：Observer设计模式是为了定义对象间的一种一对多的依赖关系，以便于当一个对象的状态改变时，其他依赖于它的对象会被自动告知并更新。Observer模式是一种松耦合的设计模式。</p>
<h2 id="实现范例的Observer设计模式"><a href="#实现范例的Observer设计模式" class="headerlink" title="实现范例的Observer设计模式"></a>实现范例的Observer设计模式</h2><p>我们之前已经对委托和事件介绍很多了，现在写代码应该很容易了，现在在这里直接给出代码，并在注释中加以说明。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> System;</div><div class="line"><span class="keyword">using</span> System.Collections.Generic;</div><div class="line"><span class="keyword">using</span> System.Text;</div><div class="line"></div><div class="line"><span class="keyword">namespace</span> <span class="title">Delegate</span> &#123;</div><div class="line">    <span class="comment">// 热水器</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Heater</span> &#123;</div><div class="line">       <span class="keyword">private</span> <span class="keyword">int</span> temperature;</div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">BoilHandler</span>(<span class="params"><span class="keyword">int</span> param</span>)</span>;   <span class="comment">//声明委托</span></div><div class="line">       <span class="keyword">public</span> <span class="keyword">event</span> BoilHandler BoilEvent;        <span class="comment">//声明事件</span></div><div class="line"></div><div class="line">       <span class="comment">// 烧水</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BoilWater</span>(<span class="params"></span>) </span>&#123;</div><div class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</div><div class="line">              temperature = i;</div><div class="line"></div><div class="line">              <span class="keyword">if</span> (temperature &gt; <span class="number">95</span>) &#123;</div><div class="line">                  <span class="keyword">if</span> (BoilEvent != <span class="literal">null</span>) &#123; <span class="comment">//如果有对象注册</span></div><div class="line">                      BoilEvent(temperature);  <span class="comment">//调用所有注册对象的方法</span></div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 警报器</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Alarm</span> &#123;</div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MakeAlert</span>(<span class="params"><span class="keyword">int</span> param</span>) </span>&#123;</div><div class="line">           Console.WriteLine(<span class="string">"Alarm：嘀嘀嘀，水已经 &#123;0&#125; 度了："</span>, param);</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 显示器</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Display</span> &#123;</div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShowMsg</span>(<span class="params"><span class="keyword">int</span> param</span>) </span>&#123; <span class="comment">//静态方法</span></div><div class="line">           Console.WriteLine(<span class="string">"Display：水快烧开了，当前温度：&#123;0&#125;度。"</span>, param);</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">class</span> <span class="title">Program</span> &#123;</div><div class="line">       <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>) </span>&#123;</div><div class="line">           Heater heater = <span class="keyword">new</span> Heater();</div><div class="line">           Alarm alarm = <span class="keyword">new</span> Alarm();</div><div class="line"></div><div class="line">           heater.BoilEvent += alarm.MakeAlert;    <span class="comment">//注册方法</span></div><div class="line">           heater.BoilEvent += (<span class="keyword">new</span> Alarm()).MakeAlert;   <span class="comment">//给匿名对象注册方法</span></div><div class="line">           heater.BoilEvent += Display.ShowMsg;       <span class="comment">//注册静态方法</span></div><div class="line"></div><div class="line">           heater.BoilWater();   <span class="comment">//烧水，会自动调用注册过对象的方法</span></div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Alarm：嘀嘀嘀，水已经 96 度了：</div><div class="line">Alarm：嘀嘀嘀，水已经 96 度了：</div><div class="line">Display：水快烧开了，当前温度：96度。</div><div class="line">// 省略...</div></pre></td></tr></table></figure></p>
<h1 id="Net-Framework中的委托与事件"><a href="#Net-Framework中的委托与事件" class="headerlink" title=".Net Framework中的委托与事件"></a>.Net Framework中的委托与事件</h1><p>尽管上面的范例很好地完成了我们想要完成的工作，但是我们不仅疑惑：为什么.Net Framework 中的事件模型和上面的不同？为什么有很多的EventArgs参数？</p>
<p>在回答上面的问题之前，我们先搞懂 .Net Framework的编码规范：</p>
<ul>
<li>委托类型的名称都应该以EventHandler结束。</li>
<li>委托的原型定义：有一个void返回值，并接受两个输入参数：一个Object 类型，一个 EventArgs类型(或继承自EventArgs)。</li>
<li>事件的命名为 委托去掉 EventHandler之后剩余的部分。</li>
<li>继承自EventArgs的类型应该以EventArgs结尾。</li>
</ul>
<p>再做一下说明：</p>
<ol>
<li>委托声明原型中的Object类型的参数代表了Subject，也就是监视对象，在本例中是 Heater(热水器)。回调函数(比如Alarm的MakeAlert)可以通过它访问触发事件的对象(Heater)。</li>
<li>EventArgs 对象包含了Observer所感兴趣的数据，在本例中是temperature。</li>
</ol>
<p>上面这些其实不仅仅是为了编码规范而已，这样也使得程序有更大的灵活性。比如说，如果我们不光想获得热水器的温度，还想在Observer端(警报器或者显示器)方法中获得它的生产日期、型号、价格，那么委托和方法的声明都会变得很麻烦，而如果我们将热水器的引用传给警报器的方法，就可以在方法中直接访问热水器了。</p>
<p>现在我们改写之前的范例，让它符合 .Net Framework 的规范：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> System;</div><div class="line"><span class="keyword">using</span> System.Collections.Generic;</div><div class="line"><span class="keyword">using</span> System.Text;</div><div class="line"></div><div class="line"><span class="keyword">namespace</span> <span class="title">Delegate</span> &#123;</div><div class="line">    <span class="comment">// 热水器</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Heater</span> &#123;</div><div class="line">       <span class="keyword">private</span> <span class="keyword">int</span> temperature;</div><div class="line">       <span class="keyword">public</span> <span class="keyword">string</span> type = <span class="string">"RealFire 001"</span>;       <span class="comment">// 添加型号作为演示</span></div><div class="line">       <span class="keyword">public</span> <span class="keyword">string</span> area = <span class="string">"China Xian"</span>;         <span class="comment">// 添加产地作为演示</span></div><div class="line">       <span class="comment">//声明委托</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">BoiledEventHandler</span>(<span class="params">Object sender, BoiledEventArgs e</span>)</span>;</div><div class="line">       <span class="keyword">public</span> <span class="keyword">event</span> BoiledEventHandler Boiled; <span class="comment">//声明事件</span></div><div class="line"></div><div class="line">       <span class="comment">// 定义BoiledEventArgs类，传递给Observer所感兴趣的信息</span></div><div class="line">       <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BoiledEventArgs</span> : <span class="title">EventArgs</span> &#123;</div><div class="line">           <span class="keyword">public</span> <span class="keyword">readonly</span> <span class="keyword">int</span> temperature;</div><div class="line">           <span class="function"><span class="keyword">public</span> <span class="title">BoiledEventArgs</span>(<span class="params"><span class="keyword">int</span> temperature</span>) </span>&#123;</div><div class="line">              <span class="keyword">this</span>.temperature = temperature;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">// 可以供继承自 Heater 的类重写，以便继承类拒绝其他对象对它的监视</span></div><div class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnBoiled</span>(<span class="params">BoiledEventArgs e</span>) </span>&#123;</div><div class="line">           <span class="keyword">if</span> (Boiled != <span class="literal">null</span>) &#123; <span class="comment">// 如果有对象注册</span></div><div class="line">              Boiled(<span class="keyword">this</span>, e);  <span class="comment">// 调用所有注册对象的方法</span></div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       </div><div class="line">       <span class="comment">// 烧水。</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BoilWater</span>(<span class="params"></span>) </span>&#123;</div><div class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</div><div class="line">              temperature = i;</div><div class="line">              <span class="keyword">if</span> (temperature &gt; <span class="number">95</span>) &#123;</div><div class="line">                  <span class="comment">//建立BoiledEventArgs 对象。</span></div><div class="line">                  BoiledEventArgs e = <span class="keyword">new</span> BoiledEventArgs(temperature);</div><div class="line">                  OnBoiled(e);  <span class="comment">// 调用 OnBolied方法</span></div><div class="line">              &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 警报器</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Alarm</span> &#123;</div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MakeAlert</span>(<span class="params">Object sender, Heater.BoiledEventArgs e</span>) </span>&#123;</div><div class="line">           Heater heater = (Heater)sender;     <span class="comment">//这里是不是很熟悉呢？</span></div><div class="line">           <span class="comment">//访问 sender 中的公共字段</span></div><div class="line">           Console.WriteLine(<span class="string">"Alarm：&#123;0&#125; - &#123;1&#125;: "</span>, heater.area, heater.type);</div><div class="line">           Console.WriteLine(<span class="string">"Alarm: 嘀嘀嘀，水已经 &#123;0&#125; 度了："</span>, e.temperature);</div><div class="line">           Console.WriteLine();</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 显示器</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Display</span> &#123;</div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShowMsg</span>(<span class="params">Object sender, Heater.BoiledEventArgs e</span>) </span>&#123;   <span class="comment">//静态方法</span></div><div class="line">           Heater heater = (Heater)sender;</div><div class="line">           Console.WriteLine(<span class="string">"Display：&#123;0&#125; - &#123;1&#125;: "</span>, heater.area, heater.type);</div><div class="line">           Console.WriteLine(<span class="string">"Display：水快烧开了，当前温度：&#123;0&#125;度。"</span>, e.temperature);</div><div class="line">           Console.WriteLine();</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">class</span> <span class="title">Program</span> &#123;</div><div class="line">       <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>) </span>&#123;</div><div class="line">           Heater heater = <span class="keyword">new</span> Heater();</div><div class="line">           Alarm alarm = <span class="keyword">new</span> Alarm();</div><div class="line"></div><div class="line">           heater.Boiled += alarm.MakeAlert;   <span class="comment">//注册方法</span></div><div class="line">           heater.Boiled += (<span class="keyword">new</span> Alarm()).MakeAlert;      <span class="comment">//给匿名对象注册方法</span></div><div class="line">           heater.Boiled += <span class="keyword">new</span> Heater.BoiledEventHandler(alarm.MakeAlert);    <span class="comment">//也可以这么注册</span></div><div class="line">           heater.Boiled += Display.ShowMsg;       <span class="comment">//注册静态方法</span></div><div class="line"></div><div class="line">           heater.BoilWater();   <span class="comment">//烧水，会自动调用注册过对象的方法</span></div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Alarm：China Xian - RealFire 001:</div><div class="line">Alarm: 嘀嘀嘀，水已经 96 度了：</div><div class="line">Alarm：China Xian - RealFire 001:</div><div class="line">Alarm: 嘀嘀嘀，水已经 96 度了：</div><div class="line">Alarm：China Xian - RealFire 001:</div><div class="line">Alarm: 嘀嘀嘀，水已经 96 度了：</div><div class="line">Display：China Xian - RealFire 001:</div><div class="line">Display：水快烧开了，当前温度：96度。</div><div class="line">// 省略 ...</div></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在本文中我首先通过一个GreetingPeople的小程序向大家介绍了委托的概念、委托用来做什么，随后又引出了事件，接着对委托与事件所产生的中间代码做了粗略的讲述。</p>
<p>在第二个稍微复杂点的热水器的范例中，我向大家简要介绍了 Observer设计模式，并通过实现这个范例完成了该模式，随后讲述了.Net Framework中委托、事件的实现方式。</p>
<p>希望这篇文章能给你带来帮助。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/17/Markdown/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Oizys">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/o1zys">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Oizys's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/17/Markdown/" itemprop="url">Markdown 简明教程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-17T17:24:10+08:00">
                2017-12-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index">
                    <span itemprop="name">Tools</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/12/17/Markdown/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/12/17/Markdown/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

<h2 id="1-斜体和粗体"><a href="#1-斜体和粗体" class="headerlink" title="1. 斜体和粗体"></a>1. 斜体和粗体</h2><p><strong>语法说明:</strong>  </p>
<pre><code>*斜体* 或者 _斜体_
**粗体**
***加粗斜体
</code></pre><p><strong>显示效果:</strong>  </p>
<blockquote>
<ul>
<li>这是<em>斜体</em></li>
<li>这是<strong>粗体</strong></li>
<li>这是<strong><em>加粗斜体</em></strong></li>
</ul>
</blockquote>
<h2 id="2-标题"><a href="#2-标题" class="headerlink" title="2. 标题"></a>2. 标题</h2><p><strong>语法说明:</strong></p>
<pre><code># 一级标题
## 二级标题
### 三级标题
#### 四级标题
... ...
</code></pre><h2 id="3-段落与换行"><a href="#3-段落与换行" class="headerlink" title="3. 段落与换行"></a>3. 段落与换行</h2><p><strong>语法说明:</strong></p>
<pre><code>无间隔换行: 在段落末加2个空格[Space][Space]
有间隔换行: 在段落后加2个换行[tr][tr]
</code></pre><p><strong>显示效果:</strong></p>
<blockquote>
<p>第一行<br>第二行</p>
<p>第一行</p>
<p>第二行</p>
</blockquote>
<h2 id="4-超链接"><a href="#4-超链接" class="headerlink" title="4. 超链接"></a>4. 超链接</h2><h3 id="4-1-自动链接"><a href="#4-1-自动链接" class="headerlink" title="4.1. 自动链接"></a>4.1. 自动链接</h3><p><strong>语法说明:</strong></p>
<pre><code>&lt;http://o1zys.github.io/&gt;
</code></pre><p><strong>显示效果:</strong></p>
<blockquote>
<p><a href="http://o1zys.github.io/" target="_blank" rel="noopener">http://o1zys.github.io/</a></p>
</blockquote>
<h3 id="4-2-行内式"><a href="#4-2-行内式" class="headerlink" title="4.2. 行内式"></a>4.2. 行内式</h3><p><strong>语法说明:</strong></p>
<p>[ ]里写链接文字，( )里写链接地址, ( )中的” “中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。[链接文字](链接地址 “链接标题”)’这样的形式。链接地址与链接标题前有一个空格。</p>
<pre><code>[Oizys&apos;s Blog](http://o1zys.github.io/ &quot;Oizys&apos;s Blog&quot;)
</code></pre><p><strong>显示效果:</strong></p>
<blockquote>
<p><a href="http://o1zys.github.io/" title="Oizys&#39;s Blog" target="_blank" rel="noopener">Oizys’s Blog</a></p>
</blockquote>
<h3 id="4-3-参考式"><a href="#4-3-参考式" class="headerlink" title="4.3. 参考式"></a>4.3. 参考式</h3><p><strong>语法说明:</strong></p>
<p>参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。</p>
<p>参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。</p>
<pre><code>经常浏览[Google][1]以及[自己的博客][2]。
[Google][1]是很好的搜索网站。
[1]:http://www.google.com &quot;Google&quot;
[2]:http://o1zys.github.com &quot;Oizys&apos;s Blog&quot;
</code></pre><p><strong>显示效果:</strong></p>
<blockquote>
<p>经常浏览<a href="http://www.google.com" title="Google" target="_blank" rel="noopener">Google</a>以及<a href="http://o1zys.github.com" title="Oizys&#39;s Blog" target="_blank" rel="noopener">自己的博客</a>。<br><a href="http://www.google.com" title="Google" target="_blank" rel="noopener">Google</a>是很好的搜索网站。</p>
</blockquote>
<h2 id="5-列表"><a href="#5-列表" class="headerlink" title="5. 列表"></a>5. 列表</h2><h3 id="5-1-无序列表"><a href="#5-1-无序列表" class="headerlink" title="5.1. 无序列表"></a>5.1. 无序列表</h3><p><strong>语法说明:</strong></p>
<p>使用 *，+，- 表示无序列表。</p>
<pre><code>- 无序列表项 一
+ 无序列表项 二
* 无序列表项 三
</code></pre><p><strong>显示效果:</strong></p>
<blockquote>
<ul>
<li>无序列表项 一</li>
</ul>
<ul>
<li>无序列表项 二</li>
</ul>
<ul>
<li>无序列表项 三</li>
</ul>
</blockquote>
<h3 id="5-2-有序列表"><a href="#5-2-有序列表" class="headerlink" title="5.2. 有序列表"></a>5.2. 有序列表</h3><p><strong>语法说明:</strong></p>
<p>使用数字表示有序列表。</p>
<pre><code>1. 有序列表项 一
2. 有序列表项 二
3. 有序列表项 三
</code></pre><p><strong>显示效果:</strong></p>
<blockquote>
<ol>
<li>有序列表项 一</li>
<li>有序列表项 二</li>
<li>有序列表项 三</li>
</ol>
</blockquote>
<h3 id="5-3-特殊情况"><a href="#5-3-特殊情况" class="headerlink" title="5.3. 特殊情况"></a>5.3. 特殊情况</h3><p>在特殊情况下，项目列表很可能会不小心产生，像是下面这样的写法：</p>
<pre><code>1986. What a great season.
</code></pre><p>会显示成</p>
<blockquote>
<ol>
<li>What a great season.</li>
</ol>
</blockquote>
<p>所以应该要改成</p>
<pre><code>1986\. What a great season.
</code></pre><p>结果才会正确</p>
<blockquote>
<p>1986. What a great season.</p>
</blockquote>
<h2 id="6-引用"><a href="#6-引用" class="headerlink" title="6. 引用"></a>6. 引用</h2><h3 id="6-1-两种引用方式"><a href="#6-1-两种引用方式" class="headerlink" title="6.1 两种引用方式"></a>6.1 两种引用方式</h3><p><strong>语法说明:</strong></p>
<pre><code>&gt; 这是一个有两段文字的引用,  
&gt; 段落1句1.  
&gt; 段落1句2.  
&gt; 
&gt; 段落2句3.  
&gt; 段落2句4.  
</code></pre><p><strong>显示效果:</strong></p>
<blockquote>
<p>这是一个有两段文字的引用,<br>段落1句1.<br>段落1句2.  </p>
<p>段落2句3.<br>段落2句4. </p>
</blockquote>
<p>Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &gt; ：</p>
<p><strong>语法说明:</strong></p>
<pre><code>&gt; 这是一个有两段文字的引用,  
段落1句1.  
段落1句2.  

&gt; 段落2句3.  
段落2句4.  
</code></pre><p><strong>显示效果:</strong></p>
<blockquote>
<p>这是一个有两段文字的引用,<br>段落1句1.<br>段落1句2.  </p>
<p>段落2句3.<br>段落2句4.</p>
</blockquote>
<h3 id="6-2-引用的多层嵌套"><a href="#6-2-引用的多层嵌套" class="headerlink" title="6.2. 引用的多层嵌套"></a>6.2. 引用的多层嵌套</h3><p><strong>语法说明:</strong></p>
<pre><code>&gt; 第一级
&gt; &gt; 第二级
&gt; &gt; &gt; 第三级

&gt; &gt; 二级

&gt; 一级
</code></pre><p><strong>显示效果:</strong></p>
<blockquote>
<p>第一级</p>
<blockquote>
<p>第二级</p>
<blockquote>
<p>第三级</p>
</blockquote>
<p>二级</p>
</blockquote>
<p>一级</p>
</blockquote>
<h2 id="7-图像"><a href="#7-图像" class="headerlink" title="7. 图像"></a>7. 图像</h2><h3 id="7-1-行内式"><a href="#7-1-行内式" class="headerlink" title="7.1. 行内式"></a>7.1. 行内式</h3><p><strong>语法说明:</strong></p>
<pre><code>![图片Alt](图片地址 “图片Title”)

![头像](https://avatars.githubusercontent.com/o1zys
 &quot;Oizys&quot;)
</code></pre><p><strong>显示效果:</strong></p>
<p><img src="https://avatars.githubusercontent.com/o1zys" alt="头像" title="Oizys"></p>
<h3 id="7-2-参考式"><a href="#7-2-参考式" class="headerlink" title="7.2. 参考式"></a>7.2. 参考式</h3><p><strong>语法说明:</strong></p>
<pre><code>在文档要插入图片的地方写![图片Alt][标记]
在文档的最后写上[标记]:图片地址 “Title”

![头像][prof_pic]
[prof_pic]:https://avatars.githubusercontent.com/o1zys
 &quot;Oizys&quot;
</code></pre><p><strong>显示效果:</strong></p>
<p><img src="https://avatars.githubusercontent.com/o1zys" alt="头像" title="Oizys"></p>
<h2 id="8-代码"><a href="#8-代码" class="headerlink" title="8. 代码"></a>8. 代码</h2><h3 id="8-1-行内式"><a href="#8-1-行内式" class="headerlink" title="8.1. 行内式"></a>8.1. 行内式</h3><p><strong>语法说明:</strong></p>
<pre><code>学习一门新语言的开始是`HelloWorld()`。
</code></pre><p><strong>显示效果:</strong></p>
<blockquote>
<p>学习一门新语言的开始是<code>HelloWorld()</code>。</p>
</blockquote>
<h3 id="8-2-缩进式多行代码"><a href="#8-2-缩进式多行代码" class="headerlink" title="8.2. 缩进式多行代码"></a>8.2. 缩进式多行代码</h3><p><strong>语法说明:</strong></p>
<p>缩进 4 个空格或是 1 个制表符。<br>一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。</p>
<pre><code>#include &lt;iostream&gt;
int main() {
    cout &lt;&lt; &quot;Hello World!&quot; &lt;&lt; endl;
}
</code></pre><p><strong>显示效果:</strong></p>
<blockquote>
<pre><code>#include &lt;iostream&gt;
int main() {
    cout &lt;&lt; &quot;Hello World!&quot; &lt;&lt; endl;
}
</code></pre></blockquote>
<h3 id="8-3-块"><a href="#8-3-块" class="headerlink" title="8.3. ``` 块"></a>8.3. ``` 块</h3><p><strong>语法说明:</strong></p>
<p>这种方式的代码块可以支持不同语言的语法高亮，要在 ``` 之后加上语言类型。</p>
<p>``` c++<br>#include <iostream><br>int main() {<br>    cout &lt;&lt; “Hello World!” &lt;&lt; endl;<br>}<br> ```</iostream></p>
<p><strong>显示效果:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World!"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="8-4-HTML原始码"><a href="#8-4-HTML原始码" class="headerlink" title="8.4. HTML原始码"></a>8.4. HTML原始码</h3><p><strong>语法说明:</strong></p>
<p>在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，剩下的 Markdown 都会帮你处理，例如：</p>
<pre><code>&lt;table&gt;
       &lt;tr&gt;
           &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt;
            &lt;th&gt;星期一&lt;/th&gt;
            &lt;th&gt;星期二&lt;/th&gt;
            &lt;th&gt;星期三&lt;/th&gt;
        &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;张三&lt;/td&gt;
        &lt;td&gt;李四&lt;/td&gt;
        &lt;td&gt;王五&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
</code></pre><p><strong>显示效果:</strong></p>
<table><br>       <tr><br>           <th rowspan="2">值班人员</th><br>            <th>星期一</th><br>            <th>星期二</th><br>            <th>星期三</th><br>        </tr><br>    <tr><br>       <td>张三</td><br>       <td>李四</td><br>       <td>王五</td><br>    </tr><br></table>


<h2 id="9-表格"><a href="#9-表格" class="headerlink" title="9. 表格"></a>9. 表格</h2><p><strong>语法说明:</strong></p>
<ol>
<li>不管是哪种方式，第一行为表头，第二行分隔表头和主体部分，第三行开始每一行为一个表格行。</li>
<li>列于列之间用管道符|隔开。原生方式的表格每一行的两边也要有管道符。</li>
<li>第二行还可以为不同的列指定对齐方向。默认为左对齐，在-右边加上:就右对齐。</li>
</ol>
<p>简单方式:</p>
<pre><code>姓名|性别|总分
-|-|-
小明|男|80
小红|女|130
小刚|男|9
</code></pre><p>原生方式:</p>
<pre><code>|姓名|姓别|总分|
|-|-|-|
|小明|男|80|
|小红|女|130|
|小刚|男|9|
</code></pre><p>为第三列指定右对齐:</p>
<pre><code>姓名|性别|总分
-|-|-:
小明|男|80
小红|女|130
小刚|男|9
</code></pre><p><strong>显示效果:</strong></p>
<p>简单方式:</p>
<blockquote>
<table>
<thead>
<tr>
<th>姓名</th>
<th>性别</th>
<th>总分</th>
</tr>
</thead>
<tbody>
<tr>
<td>小明</td>
<td>男</td>
<td>80</td>
</tr>
<tr>
<td>小红</td>
<td>女</td>
<td>130</td>
</tr>
<tr>
<td>小刚</td>
<td>男</td>
<td>9</td>
</tr>
</tbody>
</table>
</blockquote>
<p>原生方式:</p>
<blockquote>
<table>
<thead>
<tr>
<th>姓名</th>
<th>姓别</th>
<th>总分</th>
</tr>
</thead>
<tbody>
<tr>
<td>小明</td>
<td>男</td>
<td>80</td>
</tr>
<tr>
<td>小红</td>
<td>女</td>
<td>130</td>
</tr>
<tr>
<td>小刚</td>
<td>男</td>
<td>9</td>
</tr>
</tbody>
</table>
</blockquote>
<p>为第三列指定右对齐:</p>
<blockquote>
<table>
<thead>
<tr>
<th>姓名</th>
<th>性别</th>
<th style="text-align:right">总分</th>
</tr>
</thead>
<tbody>
<tr>
<td>小明</td>
<td>男</td>
<td style="text-align:right">80</td>
</tr>
<tr>
<td>小红</td>
<td>女</td>
<td style="text-align:right">130</td>
</tr>
<tr>
<td>小刚</td>
<td>男</td>
<td style="text-align:right">9</td>
</tr>
</tbody>
</table>
</blockquote>
<h2 id="10-内容目录"><a href="#10-内容目录" class="headerlink" title="10. 内容目录"></a>10. 内容目录</h2><p>在段落中填写<code>[TOC]</code>以显示全文内容的目录结构。</p>
<h2 id="11-注脚"><a href="#11-注脚" class="headerlink" title="11. 注脚"></a>11. 注脚</h2><p><strong>语法说明:</strong></p>
<p>在需要添加注脚的文字后加上脚注名字[^注脚名字],称为加注。 然后在文本的任意位置(一般在最后)添加脚注，脚注前必须有对应的脚注名字。</p>
<p>注意：经测试注脚与注脚之间必须空一行，不然会失效。成功后会发现，即使你没有把注脚写在文末，经Markdown转换后，也会自动归类到文章的最后。</p>
<pre><code>使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2]

[^1]:Markdown是一种纯文本标记语言

[^2]:HyperText Markup Language 超文本标记语言
</code></pre><p><strong>显示效果:</strong></p>
<p>使用 Markdown<a href="Markdown是一种纯文本标记语言">^1</a>可以效率的书写文档, 直接转换成 HTML[^2]。</p>
<p>[^2]:HyperText Markup Language 超文本标记语言</p>
<p><strong>注：脚注自动被搬运到最后面，请到文章末尾查看，并且脚注后方的链接可以直接跳转回到加注的地方。</strong></p>
<h2 id="12-LaTex公式"><a href="#12-LaTex公式" class="headerlink" title="12. LaTex公式"></a>12. LaTex公式</h2><p>这里采用MathJax引擎，所以在Markdown文件中必须添加</p>
<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&gt;&lt;/script&gt;
</code></pre><h3 id="12-1-表示行内公式"><a href="#12-1-表示行内公式" class="headerlink" title="12.1. $表示行内公式"></a>12.1. $表示行内公式</h3><p><strong>语法说明:</strong></p>
<pre><code>质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。
</code></pre><p><strong>显示效果:
</strong><br>质能守恒方程可以用一个很简洁的方程式 <code>$E=mc^2$</code> 来表达。</p>
<h3 id="12-2-表示整行公式"><a href="#12-2-表示整行公式" class="headerlink" title="12.2. $$表示整行公式"></a>12.2. $$表示整行公式</h3><p><strong>语法说明:</strong></p>
<pre><code>$$\sum_{i=1}^n a_i=0$$  

$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2$$  
</code></pre><p><strong>显示效果:</strong></p>
<p>$$\sum_{i=1}^n a_i=0$$</p>
<p>$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2$$</p>
<p>访问 <a href="https://math.meta.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="noopener">MathJax</a> 参考更多使用方法。</p>
<h2 id="13-分隔线"><a href="#13-分隔线" class="headerlink" title="13. 分隔线"></a>13. 分隔线</h2><p><strong>语法说明:</strong></p>
<p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>
<pre><code>* * *

***

*****

- - -

---------------------------------------
</code></pre><p><strong>显示效果:</strong></p>
<blockquote>
<hr>
<hr>
<hr>
<hr>
<hr>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/15/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Oizys">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/o1zys">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Oizys's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/15/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-15T16:18:25+08:00">
                2017-06-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Others/" itemprop="url" rel="index">
                    <span itemprop="name">Others</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/06/15/hello-world/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/06/15/hello-world/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://avatars.githubusercontent.com/o1zys"
               alt="Oizys" />
          <p class="site-author-name" itemprop="name">Oizys</p>
           
              <p class="site-description motion-element" itemprop="description">Programmer</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Oizys</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    
      <script id="dsq-count-scr" src="https://.disqus.com/count.js" async></script>
    

    

  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
